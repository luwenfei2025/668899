//@version=5
strategy("dcl-ç­–ç•¥" , overlay = true ,max_boxes_count = 500 ,max_lines_count = 500 ,max_labels_count = 500 ,max_bars_back = 5000)
//é…ç½®ç›¸å…³è¾“å…¥********************************************************
//æ˜¯å¦æ˜¾ç¤ºé¡¶ åº•
group0 = "æ˜¾ç¤ºè®¾ç½®" 
//var isAuthor = input.bool(false,"ç›¸å…³é—®é¢˜å’¨è¯¢wx:fanjianqiang2007" ,group = group0)
var isShowTopAndBottom          = input.bool(false  ,"æ˜¾ç¤ºæ‰€æœ‰é¡¶åº•"     ,group = group0)
var isShowTopBottom             = input.bool(false  ,"æ˜¾ç¤ºåˆ†å‹"         ,group = group0)
var isShowRunningPen            = input.bool(true   ,"è¿è¡Œä¸­çš„ç¬”"       ,group = group0)
var isShowMergeBar              = input.bool(false  ,"æ˜¾ç¤ºKçº¿åˆå¹¶è¿‡ç¨‹"  ,group = group0)
var isFastToPen                 = input.bool(true   ,"æ€¥é€Ÿæˆç¬”"         ,group = group0)
var isPowerfulPeek              = input.bool(true   ,"å¼ºåŠ¿åˆ†å‹ç»˜åˆ¶"     ,tooltip = "è¯¥é€‰é¡¹ä¼šåœ¨kçº¿å›¾ä¸Šå°†æ¯”è¾ƒå¼ºåŠ¿çš„åˆ†å‹è¿›è¡Œç»˜åˆ¶",group = group0)

groupFeature = "ç‰¹å¾åºåˆ—è®¾ç½®"
var isShowFeature               = input.bool(false,"æ˜¾ç¤ºç‰¹å¾åºåˆ—" ,group = groupFeature)
color p_Feature_Up              = input.color(color.rgb(8, 153, 129),"ä¸Šæ¶¨çº¿æ®µé¢œè‰²","å®šä¹‰ä¸Šæ¶¨çº¿æ®µç‰¹å¾åºåˆ—çš„é¢œè‰²", inline = "feature", group = groupFeature)
color p_Feature_Down            = input.color(color.red,"ä¸‹è·Œçº¿æ®µé¢œè‰²","å®šä¹‰ä¸‹è·Œçº¿æ®µç‰¹å¾åºåˆ—çš„é¢œè‰²",inline = "feature",group = groupFeature)
int p_Feature_Border            = input.int(2,"çº¿æ¡å®½åº¦", 1,6,group = groupFeature)

//äº¤æ˜“å»ºè®®ä¿¡æ¯ä½ç½®
//var p_trade_suggest_position = input.string(position.top_right,"äº¤æ˜“å»ºè®®æç¤ºä½ç½®",options =  [position.top_right,position.top_left,position.bottom_right,position.bottom_left] ,group = group0)
group1 = "åˆ†å‹ã€ç¬”"
int    p_max_cyc_bar            =  input.int(800,"æœ€å¤§kçº¿",0,10000,500,group = group0,tooltip ="å¯¹kçº¿åˆ†ææ•°é‡è¿›è¡Œé™åˆ¶,æ•°é‡è¶Šå°‘ç¨‹åºè¿è¡Œæ•ˆç‡è¶Šé«˜,ä¸€èˆ¬è®¾ç½®3000è¶³å¤Ÿäº†,å¤ªæ—§ä¹‹å‰çš„è¡Œæƒ…å¯¹æˆ‘ä»¬æ¥è¯´ä¹Ÿæ²¡æœ‰å¤ªå¤§æ„ä¹‰ï¼0:ä¸é™åˆ¶")
//ç¬”ç±»å‹
var p_isShowPen                 = input.bool(true,"æ˜¾ç¤ºç¬”",inline = "penshow",group = group1)
penTypeStr                      = input.string("è€ç¬”",title="ç¬”çš„ç±»å‹" ,options = ["è€ç¬”","æ–°ç¬”","4K","ä¸¥ç¬”"],inline = "pen",group = group1,tooltip = "ç¬”çš„ç±»å‹è¯´æ˜\nä¸¥ç¬”:ç»è¿‡åŒ…å«å¤„ç†åï¼Œä¸€ç¬”è‡³å°‘æœ‰5æ ¹Kçº¿,å¹¶ä¸”è¦æ±‚ä¸­é—´kçº¿ç¬¦åˆç¬”çš„æ–¹å‘\nè€ç¬”:ç»è¿‡åŒ…å«å¤„ç†åï¼Œä¸€ç¬”è‡³å°‘æœ‰5æ ¹Kçº¿\næ–°ç¬”:ä¸€ç¬”è‡³å°‘åŒ…å«4æ ¹ç»è¿‡åŒ…å«å¤„ç†åçš„Kçº¿ï¼ŒåŒæ—¶æ–°ç¬”ä¸€ç¬”ä¸­è‡³å°‘åŒ…å«5æ ¹æœªå¤„ç†åŒ…å«å…³ç³»çš„Kçº¿ \n4k:åŒ…å«å¤„ç†åå•ç‹¬4æ ¹å°±å¯æˆç¬”\n")
var oldPenMode                  = input.bool(true,"å…è®¸åˆ†å‹é‡å ",inline = "pen",group = group1)
// //ä¸€é¡¶ä¸€åº•(ä¸€ç¬”åŠ›åº¦æ¯”è¾ƒå¤§çš„æ—¶å€™)
// var specialTopBottom = input.bool(true,"ä¸€é¡¶ä¸€åº•")
//é¡¶åº•å¹…åº¦>=æŒ‡å®šå€¼å…è®¸æˆç¬”

//ç¬”çš„é¢œè‰²

color  penColr                  = input.color(color.rgb(54, 58, 69, 15),"ç¬”çš„é¢œè‰²","å®šä¹‰ç¬”çš„é¢œè‰²",inline = "group_pen_param",group = group1)
int    penWidth                 =  input.int(1,"ç¬”çš„çº¿å®½",1,10,inline = "group_pen_param",group = group1)
float  p_penToSegmentRadio      =  input.float(0,"å•ç¬”æˆæ®µ",0,1000,tooltip = "åä¸€ç¬”/å‰ä¸€çº¿æ®µè¾¾åˆ°æ­¤æ•°å€¼å¹¶ä¸”ä¹‹å‰çº¿æ®µæ²¡æœ‰ç¼ºå£å…è®¸æˆçº¿æ®µ(1å€å¡«å†™ 100)\n0:ä¸ä½¿ç”¨æ­¤æ•ˆæœ",group = group1)
p_TopAndBottom_Ratio            = input.float(0,"é¡¶åº•æˆç¬”",0,1000,tooltip="å½“é¡¶åº•åŠ›åº¦æ¯”è¾ƒå¤§æ—¶è™½ç„¶ä»åˆå¹¶åkçº¿çœ‹ä¸è¶³æ„æˆä¸€ç¬”çš„æ•°é‡,ä½†æŒ¯å¹…è¾¾åˆ°ä¸Šä¸€ç¬”æŒ‡å®šæ¯”ä¾‹(1å€å¡«å†™ 100)å…è®¸æˆç¬”\n 0:ä¸ä½¿ç”¨æ­¤åŠŸèƒ½",group = group1)

var penType = (penTypeStr =="è€ç¬”") ? 5 : (penTypeStr =="ä¸¥ç¬”") ? 5 : (penTypeStr =="æ–°ç¬”") ? -4 : (penTypeStr =="4K") ? 4 : 0



groupSegment = "çº¿æ®µ"
var p_isShowSegment                         = input.bool(true,"æ˜¾ç¤ºçº¿æ®µ",group = groupSegment)
var p_isShowBigSegment                      = input.bool(true,"æ˜¾ç¤ºè¶‹åŠ¿çº¿",group = groupSegment)
var p_segment_type_str                      = input.string("ä¸¥æ ¼æ¨¡å¼","çº¿æ®µæ¨¡å¼",options = ["å½“ä¸‹å»¶ä¼¸åä¿®æ­£","ä¸¥æ ¼æ¨¡å¼","å»¶ä¼¸æ¨¡å¼"])
var p_segmentType                           = (p_segment_type_str == "å»¶ä¼¸æ¨¡å¼") ? 2 : (p_segment_type_str == "å½“ä¸‹å»¶ä¼¸åä¿®æ­£") ? 3 : 1

color segmentColor                          = input.color(color.rgb(33, 149, 243, 30),"çº¿æ®µé¢œè‰²(æœ¬çº§åˆ«)","å®šä¹‰çº¿æ®µçš„é¢œè‰²",inline = "segment",group = groupSegment)
int   segmentWidth                          =  input.int(1,"çº¿å®½",1,10,inline = "segment",group =groupSegment)
color parentSegmentColr                     = input.color(color.rgb(76, 175, 79, 30),"çº¿æ®µé¢œè‰²(å¤§çº§åˆ«)","å®šä¹‰å¤§çº§åˆ«çº¿æ®µçš„é¢œè‰²",inline = "parentegment",group = groupSegment)
int   parentSegmentWidth                    =  input.int(1,"å¤§çº§åˆ«çº¿æ®µçº¿å®½",1,10,inline = "parentegment",group =groupSegment)
p_Segment_Change_Ratio                      = input.float(-1,"çº¿æ®µä¿®æ­£æ¯”ä¾‹",tooltip="-1:ä¸ä½¿ç”¨æ­¤åŠŸèƒ½",options = [38.2,50,61.8,78.6,-1],group = groupSegment)
group_pivot = "ä¸­æ¢"
bool  p_showPenPivot                        = input.bool(true,"æ˜¯å¦æ˜¾ç¤ºæ¬¡çº§åˆ«ä¸­æ¢",group = group_pivot)
bool p_showPivot                            = input.bool(true,"æ˜¯å¦æ˜¾ç¤ºæœ¬çº§åˆ«ä¸­æ¢",group = group_pivot)
bool p_isBeforeDrawPivot                    = input.bool(true,"æå‰ç»˜åˆ¶ç¬”ä¸­æ¢",group = group0,tooltip = "æå‰ç»˜åˆ¶ä¸­æ¢å¯ä»¥å¿«é€Ÿå¸®åŠ©æˆ‘ä»¬è§‚å¯ŸçŸ­æœŸå‹åŠ›å’Œæ”¯æ’‘")
bool p_isBeforeDrawCurrentPivot             = input.bool(false,"æå‰ç»˜åˆ¶ä¸­æ¢",group = group0,tooltip = "æå‰ç»˜åˆ¶ä¸­æ¢å¯ä»¥å¿«é€Ÿå¸®åŠ©æˆ‘ä»¬è§‚å¯ŸçŸ­æœŸå‹åŠ›å’Œæ”¯æ’‘")

color penPivotUpBgColor                     = input.color(color.rgb(49, 121, 245, 90),"ä¸Šæ¶¨ä¸­æ¢(æ¬¡çº§åˆ«)","å®šä¹‰ç¬”ä¸­æ¢çš„é¢œè‰²",inline = "pen_pivot_up",group = group_pivot)
color penPivotUpBorderColor                 = input.color(color.rgb(49, 121, 245, 0),"ä¸Šæ¶¨ç¬”ä¸­æ¢è¾¹æ¡†","å®šä¹‰ç¬”ä¸­æ¢çš„è¾¹æ¡†é¢œè‰²",inline = "pen_pivot_up",group = group_pivot)
color penPivotDownBgColor                   = input.color(color.rgb(49, 121, 245, 90),"ä¸‹è·Œä¸­æ¢(æ¬¡çº§åˆ«)","å®šä¹‰ç¬”ä¸­æ¢çš„é¢œè‰²",inline = "pen_pivot_down",group = group_pivot)
color penPivotDownBorderColor               = input.color(color.rgb(49, 121, 245, 0),"ä¸‹è·Œç¬”ä¸­æ¢è¾¹æ¡†","å®šä¹‰ç¬”ä¸­æ¢çš„è¾¹æ¡†é¢œè‰²",inline = "pen_pivot_down",group = group_pivot)
//9ç¬”å»¶ä¼¸ä¸ºæœ¬çº§åˆ«
color penExtendPivotUpBgColor               = input.color(color.rgb(255,152, 82, 80),"ä¸Šæ¶¨ä¸­æ¢(æ¬¡çº§åˆ«å»¶ä¼¸ä¸ºæœ¬çº§åˆ«)","å®šä¹‰ç¬”ä¸­æ¢çš„é¢œè‰²",  inline = "pen_pivot_up_extend",group = group_pivot)
color penExtendPivotUpBorderColor           = input.color( color.rgb(255,152, 82, 0),"ä¸Šæ¶¨ç¬”ä¸­æ¢è¾¹æ¡†","å®šä¹‰ç¬”ä¸­æ¢çš„è¾¹æ¡†é¢œè‰²",        inline = "pen_pivot_up_extend",group = group_pivot)
color penExtendPivotDownBgColor             = input.color(color.rgb(255,152, 82, 80),"ä¸‹è·Œä¸­æ¢(æ¬¡çº§åˆ«å»¶ä¼¸ä¸ºæœ¬çº§åˆ«)","å®šä¹‰ç¬”ä¸­æ¢çš„é¢œè‰²",inline = "pen_pivot_downp_extend",group = group_pivot)
color penExtendPivotDownBorderColor         = input.color(color.rgb(255,152, 82, 0),"ä¸‹è·Œç¬”ä¸­æ¢è¾¹æ¡†","å®šä¹‰ç¬”ä¸­æ¢çš„è¾¹æ¡†é¢œè‰²",      inline = "pen_pivot_downp_extend",group = group_pivot)


//æœ¬çº§åˆ«ä¸­æ¢è®¾ç½®
color pivotUpBgColor                        = input.color(color.rgb(255, 200, 82, 80),"ä¸Šæ¶¨ä¸­æ¢(æœ¬çº§åˆ«)","å®šä¹‰ä¸­æ¢çš„é¢œè‰²",inline = "pivot_up",group = group_pivot)
color pivotUpBorderColor                    = input.color( color.rgb(255, 200, 82),"ä¸Šæ¶¨ä¸­æ¢è¾¹æ¡†","å®šä¹‰ä¸­æ¢çš„è¾¹æ¡†é¢œè‰²",inline = "pivot_up",group = group_pivot)
color pivotDownBgColor                      = input.color(color.rgb(255, 200, 82, 80),"ä¸‹è·Œä¸­æ¢(æœ¬çº§åˆ«)","å®šä¹‰ä¸­æ¢çš„é¢œè‰²",inline = "pivot_down",group = group_pivot)
color pivotDownBorderColor                  = input.color(color.rgb(255, 200, 82,0),"ä¸‹è·Œä¸­æ¢è¾¹æ¡†","å®šä¹‰ç¬”ä¸­æ¢çš„è¾¹æ¡†é¢œè‰²",inline = "pivot_down",group = group_pivot)

//ä¹°å–ç‚¹
group_operatePoint = "ä¹°å–ç‚¹"
bool p_showPenOperate                       = input.bool(true,"æ¬¡çº§åˆ«ä¹°å–ç‚¹",group = group_operatePoint)
bool p_showOperate                          = input.bool(true,"æœ¬çº§åˆ«ä¹°å–ç‚¹",group = group_operatePoint)
string p_buyOrSellType                      = input.string("çº¯æ•°å­—æ˜¾ç¤º","ä¹°å–ç‚¹å±•ç°å½¢å¼",options = ["æ ‡ç­¾æ˜¾ç¤º","çº¯æ•°å­—æ˜¾ç¤º"],tooltip  = "ä¹°å–ç‚¹å±•ç°å½¢å¼ï¼Œæ ¹æ®è‡ªå·±éœ€è¦è¿›è¡Œé€‰æ‹©",group = group_operatePoint)
//ä¹°å–ç‚¹æ ‡ç­¾é¢œè‰²
color p_penBuyColor                         = input.color(color.rgb(76, 175, 79, 30),"æ¬¡çº§åˆ«ä¹°ç‚¹æ ‡ç­¾é¢œè‰²",inline = "pen_buy_color",group = group_operatePoint)
color p_penNumberBuyColor                   = input.color(color.rgb(8, 153, 129, 10),"æ¬¡çº§åˆ«ä¹°ç‚¹æ•°å­—é¢œè‰²",inline = "pen_buy_color",group = group_operatePoint)
//ä¹°å–ç‚¹æ•°å­—æ ‡è¯†é¢œè‰²
color p_penSellColor                        = input.color( color.rgb(255, 82, 82, 30),"æ¬¡çº§åˆ«å–ç‚¹æ ‡ç­¾é¢œè‰²",inline = "pen_sell_color",group = group_operatePoint)
color p_penNumberSellColor                  = input.color(color.rgb(242, 54, 54, 10),"æ¬¡çº§åˆ«å–ç‚¹æ•°å­—é¢œè‰²",inline = "pen_sell_color",group = group_operatePoint)

//å¤§çº§åˆ«ä¹°å–ç‚¹æ ‡ç­¾é¢œè‰²
color p_buyColor                            = input.color(color.rgb(33, 149, 243, 30),"æœ¬çº§åˆ«ä¹°ç‚¹æ ‡ç­¾é¢œè‰²",inline = "buy_color",group = group_operatePoint)
color p_buyNumberColor                      = input.color(color.rgb(8, 153, 129, 10),"æœ¬çº§åˆ«ä¹°ç‚¹æ•°å­—é¢œè‰²",inline = "buy_color",group = group_operatePoint)

//å¤§çº§åˆ«ä¹°å–ç‚¹æ•°å­—æ ‡è¯†é¢œè‰²
color p_sellColor                           = input.color(color.rgb(231, 216, 82, 30),"æœ¬çº§åˆ«å–ç‚¹æ ‡ç­¾é¢œè‰²",inline = "sell_color",group = group_operatePoint)
color p_sellNumberColor                     = input.color(color.rgb(242, 54, 54, 10),"æœ¬çº§åˆ«å–ç‚¹é¢œè‰²",inline = "sell_color",group = group_operatePoint)

//èƒŒé©°
group_bc = "macdèƒŒé©°"
bool p_ShowBC_low                           = input.bool(false,"æ˜¾ç¤ºæ¬¡çº§åˆ«èƒŒé©°",group = group_bc)
bool p_ShowBC                               = input.bool(false,"æ˜¾ç¤ºæœ¬çº§åˆ«èƒŒé©°",group = group_bc)
color pMacdLineColor1                       = input.color(color.yellow,"èƒŒé©°æ®µèƒŒé©°é¢œè‰²",inline = "group_bc",group = group_bc)
color pMacdLineColor2                       = input.color(color.red,"èƒŒé©°é¢œè‰²",inline = "group_bc",group = group_bc)
color pMacdLineColor3                       = input.color(color.maroon,"èƒŒé©°åŠèƒŒé©°æ®µèƒŒé©°é¢œè‰²",inline = "group_bc",group = group_bc)
int pMacdLineWidth                          = input.int(1,"èƒŒé©°çº¿å®½",1,10,inline = "group_bc_line",group = group_bc)


bool p_operatePoint_filter_part             = input.bool(false,"ä¹°å–ç‚¹åˆ†å‹è¿‡æ»¤",group = "ä¹°å–ç‚¹è¿‡æ»¤")
bool p_operatePoint_filter_part_base        = input.bool(false,"ä¹°å–ç‚¹åˆ†å‹åŸºç¡€è¿‡æ»¤",group = "ä¹°å–ç‚¹è¿‡æ»¤")
bool p_operatePoint_filter_one_operate      = input.bool(false,"1ä¹°å–macdèƒŒé©°è¿‡æ»¤",group = "ä¹°å–ç‚¹è¿‡æ»¤")
bool p_operatePoint_filter_two_operate      = input.bool(false,"2ä¹°å–ç‚¹è¿‡æ»¤",group = "ä¹°å–ç‚¹è¿‡æ»¤",tooltip = "åªæ˜¾ç¤º2ä¹°macdåœ¨0è½´ä¸Šæ–¹å¹¶ä¸”å›è°ƒæ¥è¿‘0è½´çš„")
bool p_operatePoint_filter_power            = input.bool(false,"é˜²ç‹¼æœ¯",group = "ä¹°å–ç‚¹è¿‡æ»¤")
show_ma1                                    = input(false   , "MA1", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #1")
ma1_type                                    = input.string("SMA"  , ""   , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #1", options=["SMA", "EMA"])
ma1_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #1")
ma1_length                                  = input.int(5     , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #1", minval=1)
ma1__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #1")
ma1_color                                   = input(#f6c309, ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #1")
                                        
show_ma2                                    = input(false   , "MA2", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #2")
ma2_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #2", options=["SMA", "EMA"])
ma2_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #2")
ma2_length                                  = input.int(13     , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #2", minval=1)
ma2__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #2")
ma2_color                                   = input(#fb9800, ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #2")
                                        
show_ma3                                    = input(false   , "MA3", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #3")
ma3_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #3", options=["SMA", "EMA"])
ma3_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #3")
ma3_length                                  = input.int(21    , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #3", minval=1)
ma3__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #3")
ma3_color                                   = input(#fb6500, ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #3")
                                        
show_ma4                                    = input(false   , "MA4", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #4")
ma4_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #4", options=["SMA", "EMA"])
ma4_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #4")
ma4_length                                  = input.int(34    , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #4", minval=1)
ma4__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #4")
ma4_color                                   = input(#f60c0c, ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #4")
                                        
                                        
show_ma5                                    = input(false   , "MA5", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #5")
ma5_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #5", options=["SMA", "EMA"])
ma5_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #5")
ma5_length                                  = input.int(55    , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #5", minval=1)
ma5__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #5")
ma5_color                                   = input(color.rgb(251, 153, 153), ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #5")
                                        
                                        
show_ma6                                    = input(false   , "ma6", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #6")
ma6_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #6", options=["SMA", "EMA"])
ma6_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #6")
ma6_length                                  = input.int(89    , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #6", minval=1)
ma6__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #6")
ma6_color                                   = input(color.rgb(0, 241, 242), ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #6")
                                        
show_ma7                                    = input(false   , "ma7", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #7")
ma7_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #7", options=["SMA", "EMA"])
ma7_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #7")
ma7_length                                  = input.int(144    , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #7", minval=1)
ma7__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #7")
ma7_color                                   = input(color.rgb(237, 103, 0), ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #7")
                                        
show_ma8                                    = input(false   , "ma8", group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #8")
ma8_type                                    = input.string("SMA"  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #8", options=["SMA", "EMA"])
ma8_source                                  = input(close  , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #8")
ma8_length                                  = input.int(233    , ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #8", minval=1)
ma8__width                                =  input.int(1,"çº¿å®½",1,10, group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #8")
ma8_color                                   = input(color.rgb(40, 36, 36), ""     , group = "å‡çº¿ç³»ç»Ÿè®¾ç½®", inline="MA #8")


group_strategy = "ç­–ç•¥ç›¸å…³è®¾ç½®"
group_strategy_one = "ç­–ç•¥ç›¸å…³è®¾ç½®"
bool    p_follow_trend =                    input.bool(false,"è·Ÿéšçº¿æ®µ",group = group_strategy)
bool    p_strategy_one =                    input.bool(false,"å‚ä¸1ä¹°å–ç‚¹",group = group_strategy_one)
bool    p_strategy_one_privot =             input.bool(false,"1ä¹°å–ç‚¹è‡³å°‘è¦æ±‚ä¸€ä¸­æ¢åæˆ–5ç¬”",group = group_strategy_one)
bool    p_strategy_two =                    input.bool(false,"å‚ä¸2ä¹°å–ç‚¹",group = group_strategy)
bool    p_strategy_two_privot =             input.bool(false,"2ä¹°å–ç‚¹è¦æ±‚è‡³å°‘ä¸€ä¸­æ¢å¹¶ä¸”æ²¡æœ‰å‡ºç°å¯¹æ­¤ä¸­æ¢çš„ä¸‰ä¹°å–",group = group_strategy)
bool    p_strategy_two_lei =                input.bool(false,"å‚ä¸ç±»2ä¹°å–ç‚¹",group = group_strategy)
bool    p_strategy_three =                  input.bool(false,"å‚ä¸3ä¹°å–ç‚¹",group = group_strategy)




string compareSysmbol = input.symbol("btc",title = "æ¯”ä»·ç³»ç»Ÿ")
//Debugæµ‹è¯•è°ƒè¯•å·¥å…·
type DebugInfo
    string debugInfo
    int    debugnum = 0
DebugInfo debugInfo = DebugInfo.new()
print(txt) =>
    lbl = label.new(bar_index, na, txt,tooltip = txt,xloc= xloc.bar_index, yloc= yloc.price,color= color(na))
    label.set_xy(lbl, bar_index, high)
    label.set_text(lbl, txt)
    debugInfo.debugInfo := ""
ma(source, length, type) =>
    (type == "SMA") ? ta.sma(source, length) : ta.ema(source, length)
//#regioin å¯¹è±¡å®šä¹‰
type OperatePoint
    //ä¹°å–ç‚¹ç±»å‹ -1:å–ç‚¹ 1:ä¹°ç‚¹
    int operateType
    //1,2,3ä¹°å–ç‚¹æ•°å­—
    int typeNum
    //ä¹°å–ç‚¹ä»·æ ¼
    float price
    //ä¹°å–ç‚¹æè¿°(æ¬¡çº§åˆ«+å¤§çº§åˆ«)
    string operateInfo
    //å¯¹åº”å›¾å½¢
    label operateLabel

//@type ç¬”å®šä¹‰***************************************************
//@field high ç¬”çš„é«˜ç‚¹
//@field low ç¬”çš„ä½ç‚¹
//@field penState ç¬”çš„çŠ¶æ€ 0:æˆç¬”ä½†æœªå®Œæˆ 1:å·²å®Œæˆ 2:å¾…æˆç¬”
type Pen
    float high
    float low
    int startTime = 0
    //ç»“æŸæ—¶é—´
    int endTime = 0
    //ç¬”çš„çŠ¶æ€ 1:è¿›è¡Œä¸­çš„ç¬”(æ²¡æœ‰ç¬¬ä¸‰ç¬”ç¡®å®šå°±æ˜¯æ­¤çŠ¶æ€) 2:å·²ç»å®Œæˆçš„ç¬”
    int penState = 0 
    //ç¬”æ–¹å‘  1:ä¸Šå‡ -1:ä¸‹è·Œ
    int direction = 0
    //ç»˜åˆ¶çš„çº¿
    line line
    //è¯¥ç¬”å¯¹åº”çš„ä¹°å–ç‚¹
    OperatePoint operatePoint
    //æ˜¯å¦å†…éƒ¨èƒŒé©° ä¾‹:å¦‚æœå‘ä¸‹ç¬” æœ€ä½ç‚¹ macdä¸æ˜¯æœ€å°çš„å³ä¸ºèƒŒé©°
    float[] area
    //å¯¹åº”macdé¢ç§¯
    float macdArea
//@type ä¸­æ¢å®šä¹‰ *************************************************** 
type Pivot
    float high
    float low
    //å¼€å§‹æ—¶é—´(ä½¿ç”¨æ—¶é—´é¿å… barindex è·¨åº¦è¿‡å¤§é—®é¢˜)
    int startTime = 0
    //ç»“æŸæ—¶é—´
    int endTime = 0
    //å¼€å§‹ç¬”index
    int startPenIndex = 0
    //ç»“æŸç¬”index
    int endPenIndex = 0
    //ä¸­æ¢æ–¹å‘ 1:ä¸Šæ¶¨ä¸­æ¢ -1:ä¸‹è·Œä¸­æ¢
    int direction = 0
    //ä¸­æ¢çŠ¶æ€ 1:è¿›è¡Œä¸­ 2:å®Œæˆ
    int state = 1
    //box
    box box = na
    //æå‰ç»˜åˆ¶åä¿ç•™ä¹‹å‰æ—¶é—´
    int oldEndTime = 0
//@type çº¿æ®µå®šä¹‰***********************************************
type Segment
    float high
    float low
    //å¼€å§‹æ—¶é—´(ä½¿ç”¨æ—¶é—´é¿å… barindex è·¨åº¦è¿‡å¤§é—®é¢˜)
    int startTime = 0
    //ç»“æŸæ—¶é—´
    int endTime = 0
    //å¼€å§‹ç¬”index
    int startPenIndex = 0
    //ç»“æŸç¬”index
    int endPenIndex = 0
    //çº¿æ®µçš„çŠ¶æ€ 1:å¾…ç¡®å®š 2:å·²ç¡®è®¤
    int segmentState = 0 
    //æ–¹å‘  1:ä¸Šå‡ -1:ä¸‹è·Œ
    int direction = 0
    //ç»˜åˆ¶çš„çº¿
    line line
    //åŒ…å«çš„ä¸­æ¢
    array<Pivot> pivots
    //å¯¹åº”æ¨¡æ‹Ÿç¬”å¯¹è±¡
    Pen pen = na
    //ç‰¹å¾åºåˆ—å¯¹åº”çš„çº¿æ¡ä¿¡æ¯
    line[] featureLine
//çº§åˆ«å®šä¹‰
type Grade
    //1:å½“å‰çº§åˆ« 2:ä¸Šä¸€ä¸ªçº§åˆ«
    int gradeNum = 1
    //å¯¹åº”çš„è‡ªèº«ç¬”
    Pen[] selfPens
    //å¯¹åº”çš„çº¿æ®µæ¨¡æ‹Ÿç¬”
    Pen[] pens
    //å¯¹åº”çº¿æ®µé¢œè‰²å’Œç±»å‹
    color segmentLineColor
    int   segmentWidth
    //çº¿æ®µå®Œæˆæ ·å¼
    string segmentLineNoOverStyle = line.style_dashed
    //çº¿æ®µå®Œæˆæ ·å¼
    string segmentLineOverStyle = line.style_solid
    //å¯¹åº”ä¸­æ¢èƒŒæ™¯é¢œè‰²å’Œè¾¹æ¡†ä¿¡æ¯
    color pivotUpBgColor
    color pivotDownBgColor
    color pivotUpBorderColor
    color pivotDownBordeColor
    //å¯¹åº”çº¿æ®µä¿¡æ¯
    Segment[] segments
    //å¯¹åº”å¯èƒ½çº¿æ®µä¿¡æ¯
    Segment[] ableSegments
    //ä¹°å–ç‚¹é¢œè‰²
    color buyColor
    color sellColor
    color buyNumberColor
    color sellNumberColor
    //æ˜¯å¦æ˜¾ç¤ºä¹°å–ç‚¹
    bool isShowOperate
    //å†…éƒ¨èƒŒé©°çº¿
    line innerBCLine
    float innerBCArea
    //èƒŒé©°çº¿
    line bCLine
    float bCArea
    //æ˜¯å¦æ˜¾ç¤ºçº¿æ®µ
    bool isShowLine
    //æå‰ç»˜åˆ¶ä¸­æ¢
    box pivotBeforeDrawBox
//åˆ†å‹äº‹ä»¶å®šä¹‰
type PeekEvent
    // 1:é¡¶ -1:åº•
    int     isTopOrBottom
    float   topOrBottomPrice
    int     topOrBottomTime
    int     peekBarIndex
//#endregion
//ä¹°å–ç‚¹æ˜¾ç¤º 1:æ ‡ç­¾æ˜¾ç¤º 2:çº¯æ•°å­—æ˜¾ç¤º
var buyOrSellType = (p_buyOrSellType == "çº¯æ•°å­—æ˜¾ç¤º") ? 2 : 1
//åˆå¹¶åçš„ high low
var float[] mergeHigh = array.new_float(0)
var float[] mergeLow  = array.new_float(0)
var int[]   mergeTime = array.new_int(0)
var int[]   mergeBarIndex = array.new_int(0)
var int[]   peakIndexs = array.new_int(0)
//ä¿å­˜æ‰€æœ‰ç¬”å¯¹è±¡
var array<Pen> pens = array.new<Pen>(0)
//å°†æœ¬çº§åˆ«æ®µæ¨¡æ‹Ÿæˆç¬”å­˜æ”¾åœ¨æ­¤å¤„
var array<Pen> segmentPens = array.new<Pen>(0)
//å¯èƒ½æˆç¬”çš„(åªæœ‰ä¸€ä¸ª)
var array<Pen> ablePen = array.new<Pen>(0)

//ä¿å­˜æ‰€æœ‰çº§åˆ«ä¿¡æ¯
//æ­¤å¤„æœ¬èº«å®šä¹‰ä¸ºvar ä½†å‘ç°è¯¥ç¼–ç¨‹è¯­è¨€åœ¨å¯¹è±¡å¼•ç”¨æœ‰é—®é¢˜æ•…æ­¤å»æ‰
var Grade[] grades = array.new<Grade>(0)
//ä¿å­˜å½“å‰çº§åˆ«æ‰€æœ‰çš„çº¿æ®µä¿¡æ¯
var Segment[] segments = array.new<Segment>(0)
//ä¹‹å‰å·²ç»æˆä¸ºçº¿æ®µï¼Œä½†å› ä¸ºåç»­å‘å±•å¯¼è‡´è¯¥çº¿æ®µå¤±æ•ˆï¼Œæ”¾å…¥æ­¤ä¸­åç»­åˆ¤æ–­
var Segment[] ableSegments = array.new<Segment>(0)
//ä¿å­˜å½“é«˜çº§åˆ«æ‰€æœ‰çš„çº¿æ®µä¿¡æ¯
var Segment[] hightSegments = array.new<Segment>(0)
//ä¹‹å‰å·²ç»æˆä¸ºçº¿æ®µï¼Œä½†å› ä¸ºåç»­å‘å±•å¯¼è‡´è¯¥çº¿æ®µå¤±æ•ˆï¼Œæ”¾å…¥æ­¤ä¸­åç»­åˆ¤æ–­
var Segment[] highAbleSegments = array.new<Segment>(0)
//è¡Œè¿›ä¸­çš„ç¬”,æœªç¡®å®šï¼Œåªä¾›æ˜¾ç¤ºä½¿ç”¨
var Pen runningPen = Pen.new(na,na,na,na,1,0,line.new(0,0,0,0,xloc = xloc.bar_time,style = line.style_dotted,color=penColr,width=1))
//ä¹°å–ç‚¹æŠ¥è­¦æ ‡è®°è®¾ç½® (1:ä¹° -1:å–)
float[] alertSubFlag = array.new_float() //æ¬¡çº§åˆ«
float[] alertFlag = array.new_float()//æœ¬çº§åˆ«
//æ˜¾ç¤ºçš„é¡¶åº•åˆ†å‹(åªä¿ç•™æœ€å20æ¡)
var label[] topOrBottomLabels = array.new_label(0)
//var table suggestInfo = table.new(p_trade_suggest_position, 1, 4)
//macdå‚æ•°ä¿¡æ¯
[macdLine, signalLine, histLine] = ta.macd(close,12,26,9)
var float[] macdHist = array.new_float()
//äº‹ä»¶å‘å¸ƒè®¢é˜…(ä¾¿äºå…äºè°ƒæ•´ä»£ç é¡ºåº)************
var PeekEvent[] peekEvents = array.new<PeekEvent>(na)
var float[] trendEvents = array.new<float>(na)
setTopBottomLabel(Pen _pen,int _x,float _price,int _direction)=>
    if(isShowTopBottom)
        tooltip = str.tostring(_price)+"\nArea:"+str.tostring(_pen.macdArea)
        label _label =  label.new(na,na,xloc = xloc.bar_time,yloc = yloc.price,size=size.auto)
        if(_direction == -1)
            label.set_x(_label,_x)
            //label.set_y(_label,_price-_price*0.01)
            label.set_yloc(_label,yloc.belowbar)
            label.set_color(_label,color.green)
            label.set_style(_label,label.style_triangleup)
            label.set_tooltip(_label,tooltip)
        else
            label.set_x(_label,_x)
            //label.set_y(_label,_price+_price*0.01)
            label.set_yloc(_label,yloc.abovebar)
            label.set_color(_label,color.red)
            label.set_style(_label,label.style_triangledown)
            label.set_tooltip(_label,tooltip)
        array.push(topOrBottomLabels,_label)
        int _labelNum = array.size(topOrBottomLabels)
        while(_labelNum>=30)
            label.delete(array.shift(topOrBottomLabels))
            _labelNum := array.size(topOrBottomLabels)
//æŠ¥è­¦åˆå§‹åŒ–è®¾ç½®
initAlertFlag()=>
    //ç¬¬0ä½ä¿å­˜ç¬”èµ·å§‹ä»·æ ¼ï¼Œç”¨äºåˆ¤å®šå¯¹åº”ç¬”ä¿¡æ¯
    array.push(alertSubFlag,0)
    //æ¬¡çº§åˆ«1ä¹°å–
    array.push(alertSubFlag,0)
    //æ¬¡çº§åˆ«2ä¹°å–
    array.push(alertSubFlag,0)
    //æ¬¡çº§åˆ«3ä¹°å–
    array.push(alertSubFlag,0)
    //æ¬¡çº§åˆ«ç±»2ä¹°å–
    array.push(alertSubFlag,0)
    //ç¬¬0ä½ä¿å­˜ç¬”èµ·å§‹ä»·æ ¼ï¼Œç”¨äºåˆ¤å®šå¯¹åº”ç¬”ä¿¡æ¯
    array.push(alertFlag,0)
    //æœ¬çº§åˆ«1ä¹°å–
    array.push(alertFlag,0)
    //æœ¬çº§åˆ«2ä¹°å–
    array.push(alertFlag,0)
    //æœ¬çº§åˆ«3ä¹°å–
    array.push(alertFlag,0)
    //æœ¬çº§åˆ«ç±»2ä¹°å–
    array.push(alertFlag,0)
setAlertFlag(int _gradeNum,OperatePoint _operatePoint)=>
    float _price = _operatePoint.price
    int _alertIndex = _operatePoint.typeNum
    if(_operatePoint.typeNum == -2)
        _alertIndex  := 4
        //print("******")
    //è®¾ç½®æŠ¥è­¦æ ‡å¿—
    if(_gradeNum == 1)
        array.set(alertSubFlag,_alertIndex,_operatePoint.operateType==1?_price:-_price)
    else
        array.set(alertFlag,_alertIndex,_operatePoint.operateType==1?_price:-_price)
//ç³»ç»Ÿå¯åŠ¨æ˜¯é¦–æ¬¡åˆå§‹åŒ–çº§åˆ«ä¿¡æ¯
initGrade() =>
    if(array.size(grades)<=0)
        //åˆå§‹åŒ–ä½çº§åˆ«ä¿¡æ¯(æ— ç”¨)
        Grade preGrade = Grade.new(0,segmentPens,pens,segmentColor,segmentWidth,line.style_dashed,line.style_solid,
                 penPivotUpBgColor,penPivotDownBgColor,penPivotUpBorderColor,penPivotDownBorderColor,segments,ableSegments)
        preGrade.buyColor:= p_penBuyColor
        preGrade.sellColor:= p_penSellColor
        preGrade.isShowOperate :=p_showPenOperate
        //åˆå§‹åŒ–æœ¬çº§åˆ«ä¿¡æ¯
        Grade currentGrade = Grade.new(1,segmentPens,pens,segmentColor,segmentWidth,line.style_dotted,line.style_solid,
                 penPivotUpBgColor,penPivotDownBgColor,penPivotUpBorderColor,penPivotDownBorderColor,segments,ableSegments)
        //æ ‡ç­¾é¢œè‰²
        currentGrade.buyColor:= p_penBuyColor
        currentGrade.sellColor:= p_penSellColor
        //æ•°å­—é¢œè‰²
        currentGrade.buyNumberColor:= p_penNumberBuyColor
        currentGrade.sellNumberColor:= p_penNumberSellColor
        currentGrade.isShowOperate :=p_showPenOperate
        currentGrade.innerBCLine := line.new(na,na,na,na,xloc = xloc.bar_time,color = color.yellow,style = line.style_solid,width = 100)
        currentGrade.bCLine := line.new(na,na,na,na,xloc = xloc.bar_time,color = color.red,style = line.style_solid,width = 100)
        currentGrade.isShowLine := p_isShowSegment
        currentGrade.pivotBeforeDrawBox := box.new(na,na,na,na,xloc = xloc.bar_time,border_style = line.style_dotted)

        //åˆå§‹åŒ–ä¸Šä¸€çº§åˆ«ä¿¡æ¯
        Grade nextGrade = Grade.new(2,array.new<Pen>(),segmentPens,parentSegmentColr,parentSegmentWidth,line.style_dotted,line.style_dashed,
                 pivotUpBgColor,pivotDownBgColor,pivotUpBorderColor,pivotDownBorderColor,hightSegments,highAbleSegments)
        nextGrade.buyColor:= p_buyColor
        nextGrade.sellColor:= p_sellColor
        nextGrade.buyNumberColor:= p_buyNumberColor
        nextGrade.sellNumberColor:= p_sellNumberColor
        nextGrade.isShowOperate :=p_showOperate
        nextGrade.innerBCLine := line.new(na,na,na,na,xloc = xloc.bar_time,color = color.yellow,style = line.style_solid,width = 100)
        nextGrade.bCLine := line.new(na,na,na,na,xloc = xloc.bar_time,color = color.red,style = line.style_solid,width = 100)
        nextGrade.isShowLine := p_isShowBigSegment
        nextGrade.pivotBeforeDrawBox := box.new(na,na,na,na,xloc = xloc.bar_time,border_style = line.style_dotted)
        array.insert(grades,0,preGrade)
        array.insert(grades,1,currentGrade)
        array.insert(grades,2,nextGrade)
getGradePens(int _gradeNum)=>
    (_gradeNum == 1) ? pens : segmentPens
getGradeSelfPens(int _gradeNum)=>
    (_gradeNum == 1) ? segmentPens : array.new<Pen>()
getGradeSegments(int _gradeNum)=>
    (_gradeNum == 1) ?segments:hightSegments
getGradeAbleSegments(int _gradeNum)=>
    (_gradeNum == 1) ? ableSegments : highAbleSegments
          
clearFeature(Segment _segment)=>
    if(not na(_segment.featureLine) and array.size(_segment.featureLine)>0)
        for i = 0 to array.size(_segment.featureLine)-1
            line.delete(array.get(_segment.featureLine,i))
        _segment.featureLine := array.new<line>()
drawSingleFeature(int _gradeNum,Segment _segment)=>
    Pen[] _pens= getGradePens(_gradeNum)
    Segment[] _segments = getGradeSegments(_gradeNum)
    //debugInfo.debugInfo := ""
    //ä»èµ·å§‹åˆå¹¶åˆ°é¡¶ç‚¹
    for i = _segment.startPenIndex to array.size(_pens) - 1
        Pen _pen = array.get(_pens,i)
        if(_pen.direction == _segment.direction)
            continue
        //å–å¾—æœ€åçš„ç‰¹å¾kçº¿
        line _lastLine = na
        if( array.size(_segment.featureLine) > 0  )
            _lastLine := array.last(_segment.featureLine)

        if(na(_lastLine))
            line _templine = line.new(na,na,na,na,xloc = xloc.bar_time,color = _segment.direction==1?p_Feature_Up:p_Feature_Down,style = line.style_arrow_right,width = p_Feature_Border)
            array.push(_segment.featureLine,_templine)
            line.set_xy1(_templine,_pen.startTime,_pen.direction == 1?_pen.low:_pen.high)
            line.set_xy2(_templine,_pen.endTime,_pen.direction == 1?_pen.high:_pen.low)
            //debugInfo.debugInfo += "\n:-----------------0:"+str.tostring(_pen.high)+":"+str.tostring(_pen.low)
        else
            //åˆ¤æ–­å½“å‰ç‰¹å¾kçº¿æ˜¯å¦å’Œä¹‹å‰ç‰¹å¾kçº¿å­˜åœ¨åŒ…å«å…³ç³»
            bool _hasContains = false
            if(_pen.direction == 1 and  line.get_y1(_lastLine) <= _pen.low and line.get_y2(_lastLine) >= _pen.high )//å‘ä¸Š
                _hasContains := true
            if(_pen.direction == -1 and line.get_y1(_lastLine) >= _pen.high and line.get_y2(_lastLine) <= _pen.low )//å‘ä¸‹
                _hasContains := true
            // if(_hasContains and array.indexof(_pens,_pen) == _segment.endPenIndex+1)
            //     _hasContains := false  
            if(_hasContains)
                //debugInfo.debugInfo += "\n:-----------------1:"+str.tostring(_pen.high)+":"+str.tostring(_pen.low)
                if(_pen.direction==1 and _pen.high <= line.get_y2(_lastLine))
                    line.set_xy2(_lastLine,_pen.endTime,_pen.high)
                if(_pen.direction==-1 and _pen.low >= line.get_y2(_lastLine))
                    line.set_xy2(_lastLine,_pen.endTime,_pen.low)
            else
                //debugInfo.debugInfo += "\n*********************************************2:"+str.tostring(_pen.high)+":"+str.tostring(_pen.low)
                line _templine = line.new(na,na,na,na,xloc = xloc.bar_time,color = _segment.direction==1?p_Feature_Up:p_Feature_Down,style = line.style_arrow_right,width = p_Feature_Border)
                line.set_xy1(_templine,_pen.startTime,_pen.direction == 1?_pen.low:_pen.high)
                line.set_xy2(_templine,_pen.endTime,_pen.direction == 1?_pen.high:_pen.low)
                array.push(_segment.featureLine,_templine)
                if(array.size(_segment.featureLine)>=2 and i > _segment.endPenIndex + 1)
                    line _preLine = array.get(_segment.featureLine,array.size(_segment.featureLine)-2)
                    //å¦‚æœå‡ºç°ç‰¹å¾åˆ†å‹ç›´æ¥è·³å‡ºå¾ªç¯
                    if(_segment.direction ==  1 and _pen.low < line.get_y2(_lastLine) )
                        break
                    else if(_segment.direction ==  -1 and _pen.high > line.get_y2(_lastLine) )
                        break
            if(array.indexof(_pens,_pen) == _segment.endPenIndex+1 and array.size(_segment.featureLine) >= 3)
                for j = 0 to array.size(_segment.featureLine) - 3
                    line.delete(array.get(_segment.featureLine,j))




    // if(array.indexof(_segments,_segment) == 0)
    //     debugInfo.debugInfo += "\n  _segment.startPenIndex:"+str.tostring( _segment.startPenIndex)+"\n size:"+str.tostring(array.size(_pens))+"\nline:"+str.tostring(array.size(_segment.featureLine))
    //     //print(debugInfo.debugInfo)
//ç»™æŒ‡å®šçº¿æ®µç»˜åˆ¶ç‰¹å¾åºåˆ—ä¿¡æ¯(å½“å‰åªæ˜¾ç¤ºç¬”)
drawFeature(int _gradeNum)=>
    Pen[] _pens= getGradePens(_gradeNum)
    Segment[] _segments = getGradeSegments(_gradeNum)
    if(array.size(_segments)>0 and isShowFeature)
        for i = (array.size(_segments) - 5 >= 0 ? array.size(_segments) - 5 : 0) to  array.size(_segments)- 1 
            Segment _segment = array.get(_segments , i )
            clearFeature(_segment)
            if( array.size(_segments) - 3 <= array.indexof(_segments,_segment)  )
                drawSingleFeature(_gradeNum,_segment)
        // int i = 4
        // while(i >= 0)
        //     if(array.size(_segments) >= i )
        //         Segment _segment = array.get(_segments,array.size(_segments) - i  )
        //         //æ¸…é™¤ä¹‹å‰çº¿æ®µ
        //         clearFeature(_segment)
        //         //drawSingleFeature(_gradeNum,_segment)
        //     else
        //         continue
        //     i := i-1



//#region @function åˆå¹¶å¤„ç†åŒ…å«å…³ç³»çš„bar å¹¶ä»å·²ç»å¤„ç†å®Œåˆå¹¶å…³ç³»çš„barä¸­æŸ¥æ‰¾ é¡¶ åº•
//@return [isTopOrBottom,topOrBottomTime,topOrBottomPrice]
mergeBarAndFindTopAndBottom(bool isCyc) =>
    if(isCyc)
        //æœ€åä¸€ç¬”
        Pen _lastPen = na
        if(array.size(pens) > 1)
            _lastPen := array.get(pens,array.size(pens)-1)
        //å–å¾—æœ€åä¸€æ¬¡å¤„ç†åˆå¹¶åçš„bar,å¦‚æœå½“å‰æ²¡æœ‰çš„è¯ä½¿ç”¨ä¸Šä¸€æ ¹bar
        preHigh = high[1]
        preLow  = low[1]
        preTime = time[1]
        preBarIndex = bar_index[1]
        if( array.size(mergeHigh)>0 )
            preHigh := array.pop(mergeHigh)
        if( array.size(mergeLow)>0 )
            preLow := array.pop(mergeLow)
        if( array.size(mergeTime)>0 )
            preTime := array.pop(mergeTime)
        if( array.size(mergeBarIndex)>0 )
            preBarIndex := array.pop(mergeBarIndex)
        //åˆ¤æ–­æ˜¯å¦å­˜åœ¨åŒ…å«å…³ç³»
        isLeftContain  =   (preHigh >= high and preLow <= low)
        isRightContain =   (high >= preHigh and low <= preLow)
        isContain      =   isLeftContain or isRightContain
        //å½“å‰åˆå¹¶kçº¿æ–¹å‘ 0:æ— æ–¹å‘ 1:ä¸Šå‡ -1:ä¸‹é™
        direction      =if not isContain
            high >= preHigh ? 1 : -1
        else
            if(array.size(mergeHigh) >= 1)
                preHigh >= array.get(mergeHigh,array.size(mergeHigh) -1 ) ? 1 : -1
            else
                preHigh >= preHigh[1] ? 1 : -1
        // if(array.size(pens)>0 and isContain)
        //     Pen _lastPen = array.get(pens,array.size(pens)-1)
        //     if(_lastPen.direction == 1 and high > _lastPen.high)
        //         isContain := false
        //     else if(_lastPen.direction == -1 and low < _lastPen.low)
        //         isContain := false
        if (isContain)
            array.push(mergeHigh,direction == 1 ? math.max(high , preHigh) :  math.min(high , preHigh))
            array.push(mergeLow ,direction == 1 ? math.max(low  , preLow)  :  math.min(low  , preLow))
            //æ—¶é—´è®¾ç½®ä¸ºåŒ…å«å…³ç³»ä¸­é¡ºåº”æ–¹å‘çš„æå€¼baræ—¶é—´
            array.push(mergeTime,direction == 1 ? (high >= preHigh ? time :preTime) : (low <= preLow ? time :preTime) )
            array.push(mergeBarIndex,direction == 1 ? (high >= preHigh ? bar_index :preBarIndex) : (low <= preLow ? bar_index :preBarIndex))
            preTime := array.get(mergeTime,array.size(mergeTime) - 1)
        else
            array.push(mergeHigh, preHigh )
            array.push(mergeLow , preLow )
            array.push(mergeTime, preTime)
            array.push(mergeBarIndex,preBarIndex)
            array.push(mergeHigh, high )
            array.push(mergeLow , low )
            array.push(mergeTime, time)
            array.push(mergeBarIndex,bar_index)
        // //ä¿®å¤é—®é¢˜ï¼Œå‡ºç°æ¯”å‰é¢æ›´æœ‰åˆ©çš„æå€¼ï¼Œä½†å› ä¸ºåŒ…å«å…³ç³»å¤„ç†åæ— æ³•ä½“ç°
        if(not na(_lastPen) and not isContain)
            if(_lastPen.direction == 1 and high > high[1] and low > low[1] )
                isContain := false
            else if(_lastPen.direction == -1 and high < high[1] and low < low[1] )
                isContain := false
        //#2:æµ‹è¯•æ‰¾åˆ°æ‰€æœ‰çš„é¡¶åº•åˆ†å‹(3æ ¹ä¸é‡åˆçš„ï¼Œä¸­é—´ä¸€æ ¹æ˜¯æå€¼)
        isUp     =     bool(na)
        isDown   =     bool(na)
        isTop    =     bool(na)
        isBottom =     bool(na)

        //åˆå¹¶å¤„ç†åé‡Œé¢æœ‰è‡³å°‘2æ ¹kçº¿ï¼Œåˆ¤æ–­é¡¶åº•
        if(array.size(mergeHigh)>=2)
            mergeBarLastHigh = array.get(mergeHigh,array.size(mergeHigh)-1)
            mergeBarLastLow  = array.get(mergeLow,array.size(mergeLow)-1)
            mergeBarLastPreHigh = array.get(mergeHigh,array.size(mergeHigh)-2)
            mergeBarLastPreLow  = array.get(mergeLow,array.size(mergeLow)-2)
            isUp     :=     mergeBarLastHigh > mergeBarLastPreHigh and mergeBarLastLow > mergeBarLastPreLow
            isDown   :=     mergeBarLastHigh < mergeBarLastPreHigh and mergeBarLastLow < mergeBarLastPreLow
            isTop    :=     isUp[1]   and isDown
            isBottom :=     isDown[1] and isUp

        if(isShowTopAndBottom)
            label _label = label.new(na,na,xloc = xloc.bar_time,size=size.auto)
            if(isTop)//é¡¶åˆ†å‹
                tooltip = str.tostring(array.get(mergeHigh,array.indexof(mergeTime,preTime)))
                label.set_xy(_label,preTime,na)
                label.set_yloc(_label,yloc.abovebar)
                label.set_color(_label,color.red)
                label.set_style(_label,label.style_triangledown)
                label.set_tooltip(_label,tooltip)
            if(isBottom)//åº•åˆ†å‹
                tooltip = str.tostring(array.get(mergeLow,array.indexof(mergeTime,preTime)))
                label.set_xy(_label,preTime,na)
                label.set_yloc(_label,yloc.belowbar)
                label.set_color(_label,color.green)
                label.set_style(_label,label.style_triangleup)
                label.set_tooltip(_label,tooltip)
        //é¡¶ åº•   
        isTopOrBottom  = (isTop) ? 1 : isBottom ? -1 : 0
        //å¯¹åº”çš„kçº¿æ—¶é—´
        int topOrBottomTime = na
        if(isTopOrBottom == 1 or isTopOrBottom == -1)
            topOrBottomTime := preTime
        //å¯¹åº”çš„ä»·æ ¼
        float topOrBottomPrice = na
        array.push(peakIndexs,0)
        if(isTopOrBottom == 1)
            topOrBottomPrice := array.get(mergeHigh,array.indexof(mergeTime,topOrBottomTime))
            array.set(peakIndexs,array.indexof(mergeTime,topOrBottomTime),1)
        else if(isTopOrBottom == -1)
            topOrBottomPrice := array.get(mergeLow,array.indexof(mergeTime,topOrBottomTime))
            array.set(peakIndexs,array.indexof(mergeTime,topOrBottomTime),-1)

        if(isTopOrBottom != 0)
            array.push(peekEvents, PeekEvent.new(isTopOrBottom,topOrBottomPrice,topOrBottomTime,array.get(mergeBarIndex,array.indexof(mergeTime,topOrBottomTime))))
        [isTopOrBottom,topOrBottomTime,topOrBottomPrice]
    else
        [0,0,0]
//#endregion
//#region ç¬”ç›¸å…³æ–¹æ³•
// //æ¸…ç†å¤šå°‘æ¡ä¹‹å‰çš„ä¹°å–ç‚¹
// clearPenOperate()=>

//ç»˜åˆ¶ç¬”å¯¹åº”çš„ä¹°å–ç‚¹æ ‡è®°
drawPenOperate(int _gradeNum,Pen _pen)=>
    Grade _grade = array.get(grades,_gradeNum)
    OperatePoint _operatePoint = _pen.operatePoint
    if(not na(_operatePoint) and _grade.isShowOperate)
        if(not na(_operatePoint.operateLabel))
            label.delete(_operatePoint.operateLabel)
        string _yloc = _operatePoint.operateType==1?yloc.belowbar:yloc.abovebar
        string _style = _operatePoint.operateType==1? label.style_label_up:label.style_label_down
        string _text = str.tostring(_operatePoint.typeNum)
        string _tooltip = str.tostring(_operatePoint.price)
        //æ·»åŠ macdèƒŒé©°é¢ç§¯æ•°æ®
        if(not na(_grade.bCArea))
            _tooltip += "\nMACDé¢ç§¯:"+str.tostring(_grade.innerBCArea)+":"+str.tostring(_grade.bCArea)
        string _size = size.small
        if(_gradeNum>1)
            _size := size.normal
        label _label = na
        if(buyOrSellType == 1)
            if(_operatePoint.typeNum<0)//ç±»ä¹°å–ç‚¹
                string _showText = "ğŸ’£"
                if(_operatePoint.typeNum == -2 and _operatePoint.operateType>0)
                    _showText := "ğŸ®"
                _label := label.new(_pen.endTime,_operatePoint.price,xloc = xloc.bar_time
                     ,size=_size,yloc=_yloc,style=label.style_none,tooltip=_tooltip,textalign =text.align_center
                     ,text=_showText)
            else //æ­£å¸¸ä¹°å–ç‚¹
                //ç»˜åˆ¶ä¹°å–ç‚¹æ ‡ç­¾
                _label := label.new(_pen.endTime,_operatePoint.price,xloc = xloc.bar_time
                     ,size=_size,yloc=_yloc,style=_style,text=_text,tooltip=_tooltip,textalign =text.align_center
                     ,color =_operatePoint.operateType>0? _grade.buyColor:_grade.sellColor
                     ,textcolor= _operatePoint.operateType>0? _grade.buyNumberColor:_grade.sellNumberColor)
        else
            _text+=(_operatePoint.operateType==1?"ä¹°":"å–")
            if(_operatePoint.typeNum<0)//ç±»ä¹°å–ç‚¹
                string _showText = "ç±»2å–"
                if(_operatePoint.typeNum == -2 and _operatePoint.operateType>0)
                    _showText := "ç±»2ä¹°"
                _label := label.new(_pen.endTime,_operatePoint.price,xloc = xloc.bar_time
                     ,size=_size,yloc=_yloc,style=label.style_none,tooltip=_tooltip,textalign =text.align_center
                     ,color =color.white
                     ,textcolor= _operatePoint.operateType>0? _grade.buyNumberColor:_grade.sellNumberColor
                     ,text=_showText)
            else //æ­£å¸¸ä¹°å–ç‚¹
                //ç»˜åˆ¶ä¹°å–ç‚¹æ ‡ç­¾
                _label := label.new(_pen.endTime,_operatePoint.price,xloc = xloc.bar_time
                     ,size=_size,yloc=_yloc,style=_style,text=_text,tooltip=_tooltip,textalign =text.align_center
                     ,color =color.rgb(255, 255, 255,100)
                     ,textcolor= _operatePoint.operateType>0? _grade.buyNumberColor:_grade.sellNumberColor)
        _operatePoint.operateLabel := _label
    true
delDrawPenOperate(int _gradeNum,Pen _pen)=>
    Grade _grade = array.get(grades,_gradeNum)
    OperatePoint _operatePoint = _pen.operatePoint
    if(not na(_operatePoint) and _grade.isShowOperate)
        if(not na(_operatePoint.operateLabel))
            //print("del")
            label.delete(_operatePoint.operateLabel) 
        _pen.operatePoint :=na
    true
//è·å¾—æŒ‡å®šç¬”æœ€è¿‘çš„ä¸€ä¸ªä¸­æ¢(åœ¨æœ€åçº¿æ®µ,ä¸åŒ…å«è‡ªèº«æ‰€åœ¨ä¸­æ¢)
getLastPivotByPen(int _gradeNum,Pen _pen)=>
    Grade _grade = array.get(grades,_gradeNum)
    Segment[] _segments = getGradeSegments(_gradeNum)
    Pen[] _pens= getGradePens(_gradeNum)
    Segment _operateSegament =  array.get(_segments,array.size(_segments)-1)
    Pivot _prePivot = na
    if(na(_prePivot))
        for j=0 to array.size(_operateSegament.pivots)>0 ? array.size(_operateSegament.pivots)-1:na
            Pivot _pivot = array.get(_operateSegament.pivots,j)
            if(_pivot.endTime < _pen.endTime)
                _prePivot := _pivot
    _prePivot
//è·å¾—è‡ªèº«æ‰€åœ¨çš„ä¸­æ¢
getSelfPivotByPen(int _gradeNum,Pen _pen)=>
    Grade _grade = array.get(grades,_gradeNum)
    Segment[] _segments = getGradeSegments(_gradeNum)
    Pen[] _pens= getGradePens(_gradeNum)
    Segment _operateSegament =  array.get(_segments,array.size(_segments)-1)
    Pivot _selfPivot = na
    //é¦–å…ˆå–å¾—è‡ªèº«æ‰€åœ¨ä¸­æ¢ï¼Œå¦‚æœè‡ªèº«æ²¡æœ‰çš„è¯å†æ‰¾ä¸Šä¸€ä¸ªä¸­æ¢
    for j=0 to array.size(_operateSegament.pivots)>0 ? array.size(_operateSegament.pivots)-1:na
        Pivot _pivot = array.get(_operateSegament.pivots,j)
        if(_pivot.startTime<=_pen.startTime and  _pivot.endTime >= _pen.endTime)
            _selfPivot := _pivot
    _selfPivot
//æ£€æµ‹ä¹°å–ç‚¹åˆ†å‹è¿‡æ»¤(å¦‚:åº•åˆ†å‹ï¼Œæœ€å³è¾¹kçº¿è¦æ±‚ 1:ç»¿è‰² 2::æ”¶ç›˜ä»·è¦é«˜äºåº•kæœ€é«˜å¤„)
filterOperateType(int _gradeNum,Pen _pen)=>
    bool isResult = false
    //å–å¾—éªŒè¯åˆ†å‹
    int _direction = _pen.direction
    //å–å¾—åˆ†å‹æœ€åK
    if(_gradeNum == 1)
        int _kBarIndexCurrent = bar_index - array.get(mergeBarIndex,array.indexof(mergeTime,_pen.endTime))
        int _kBarIndexNext =_kBarIndexCurrent+1
        float _close = close[_kBarIndexNext]
        float _open = open[_kBarIndexNext]
        float _high = high[_kBarIndexNext]
        float _low = low[_kBarIndexNext]
        //print("1_kBarIndexCurrent:"+str.tostring(_kBarIndexCurrent)+"\n_kBarIndexNext:"+str.tostring(_kBarIndexNext))
        //print("_close:"+str.tostring(_close)+"\n_open:"+str.tostring(_open))
        if(_direction == 1)
            float _topHighPrice = high[_kBarIndexCurrent]
            if(_open > _close and _high < _topHighPrice)
                isResult := true
        else if(_direction == -1)
            float _topOrLowPrice = low[_kBarIndexCurrent]
            if(_open < _close and _low > _topOrLowPrice)
                isResult := true
    else
        isResult := true
    isResult
//åˆ†å‹åœé¡¿è¿‡æ»¤ 
filterOperateVerifyType(int _gradeNum,Pen _pen)=>
    bool isResult = false
    //å–å¾—éªŒè¯åˆ†å‹
    int _direction = _pen.direction
    if(_gradeNum == 1 )
        int _kBarIndexCurrent =bar_index -  array.get(mergeBarIndex,array.indexof(mergeTime,_pen.endTime))
        int _kBarIndexNext =_kBarIndexCurrent+1
        float _close = close[_kBarIndexNext]
        float _high = high[_kBarIndexNext]
        float _low = high[_kBarIndexNext]
        //print("2_kBarIndexCurrent:"+str.tostring(_kBarIndexCurrent)+"\n_kBarIndexNext:"+str.tostring(_kBarIndexNext))
        //å–å¾—ç¬”çš„å¹…åº¦å€¼
        float _penPriceAmplitude = math.abs(_pen.high - _pen.low)
        if(_direction == 1)
            float _topOrLowPrice = low[_kBarIndexCurrent]
            if(_close<=_topOrLowPrice)
                isResult := true
            //å¦‚æœä¸æˆç«‹çš„è¯æœ€åkçº¿æ”¶ç›˜ä»·å·²ç»è¾¾åˆ°ç¬”çš„50%
            else
                if( (_pen.high - _low)/_penPriceAmplitude >=0.5 )
                    isResult := true 
        else if(_direction == -1)
            float _topOrLowPrice = high[_kBarIndexCurrent]
            //print("_close:"+str.tostring(_close)+"\n_topOrLowPrice:"+str.tostring(_topOrLowPrice))
            if(_close>=_topOrLowPrice)
                //print("_close:"+str.tostring(_close)+"\n_topOrLowPrice:"+str.tostring(high[_kBarIndexCurrent]))
                isResult := true 
            //å¦‚æœä¸æˆç«‹çš„è¯æœ€åkçº¿æ”¶ç›˜ä»·å·²ç»è¾¾åˆ°ç¬”çš„50%
            else
                if( (_high -_pen.low)/_penPriceAmplitude >=0.5 )
                    isResult := true 

    isResult


//è·å¾—æŒ‡å®šç¬”å¯¹åº”çš„macdé¢ç§¯
setPenMacdArea(Pen _pen)=>
    float _area = 0
    int _endBarIndex = array.get(mergeBarIndex,array.indexof(mergeTime,_pen.endTime))
    int _startBarIndex = array.get(mergeBarIndex,array.indexof(mergeTime,_pen.startTime))
    float[] _areas = array.slice(macdHist,  _startBarIndex ,_endBarIndex +1)
    _pen.area := _areas
    for int i=0 to array.size(_areas)-1
        _area += math.abs(array.get(_areas,i))
    _pen.macdArea := _area
    

        
//æ€»çš„ä¹°å–ç‚¹è¿‡æ»¤
filterOperate(int _gradeNum,Segment _segment,Pen _pen)=>
    //åªå¯¹è¿›è¡Œä¸­çš„ç¬”è¿›è¡Œè¿‡æ»¤
    Pen[] _pens= getGradePens(_gradeNum)
    //è¿‡æ»¤åªé’ˆå¯¹å½“å‰æœ€åä¸€ç¬”
    if(array.indexof(_pens,_pen) == array.size(_pens)-1 and _gradeNum==1)
        Pen _checkPen = _pen
        if(_gradeNum>1)
            _checkPen := array.get(_pens,_segment.endPenIndex)
        //print("*******************")
        int maxNum = 0
        //åŸºç¡€åˆ†å‹è¿‡æ»¤
        if(p_operatePoint_filter_part_base)
            maxNum += 1
        //éœ€è¦åˆ†å‹åœé¡¿éªŒè¯
        if(p_operatePoint_filter_part)
            maxNum += 1
        int checkResult = 0
        if(p_operatePoint_filter_part_base)
            if(filterOperateType(_gradeNum,_checkPen))
                checkResult +=1
        if(p_operatePoint_filter_part)
            if(filterOperateVerifyType(_gradeNum,_checkPen))
                checkResult +=1
        //print("checkResult:"+str.tostring(checkResult)+"\nmaxNum:"+str.tostring(maxNum))
        checkResult >=maxNum
    else
        true

//æŸ¥è¯¢å½“å‰ä¸ºå®Œç»“çš„è®¢å•ä¸­æ˜¯å¦å­˜åœ¨æŒ‡å®šIDçš„è®¢å•
// findOrderBy(string orderid)=>
//     ret = -1
//     if(strategy.opentrades==0)
//         ret
//     else
//         for i=0 to strategy.opentrades-1
//             if(strategy.opentrades.entry_id(i) == orderid)
//                 ret := i
//                 break
//         ret
// *ä¹°å–ç‚¹ç­–ç•¥çš„ä½¿ç”¨
// *@param _gradeNum:ç­‰çº§
// *@param _segment:æ‰€å±çº¿æ®µ
// *@parm _pen :æ‰€å±ç¬”
// *@parm _operatePoint:å¯¹åº”ä¹°å–ç‚¹ä¿¡æ¯
strategyCreate(int _gradeNum,Segment _segment,Pen _pen,OperatePoint _operatePoint)=>
    // true  
    if( (p_follow_trend and _operatePoint.operateType != _segment.direction) or not p_follow_trend)
        Pen[] _pens= getGradePens(_gradeNum)
        Segment[] _segments = getGradeSegments(_gradeNum)
        bool isCreateStrategy = true
        //çº¿æ®µåŒ…å«ä¸­æ¢æ•°é‡
        int  _pivotNum = _segment.pivots.size()  
        //çº¿æ®µåŒ…å«ç¬”æ•°é‡
        int _segmentPenNum = _segment.endPenIndex - _segment.startPenIndex + 1
        //å–å¾—ä¸Šä¸€ç¬”
        Pen _prePen = na
        if(array.size(_pens)>=2)
            _prePen := array.get(_pens,array.indexof(_pens,_pen))
        //å–å¾—ä¸Šä¸€ä¸ªçº¿æ®µ
        Segment _preSegment = na
        if(array.size(_segments)>=2)
            _preSegment := array.get(_segments,array.indexof(_segments,_segment))
        //å¦‚æœæ˜¯ä¸€ä¹°å–çš„è¯
        if(_operatePoint.typeNum == 1 and p_strategy_one)
            //éªŒè¯æ˜¯å¦åŒ…å«ä¸­æ¢æˆ–è€…5ç¬”è½¬æŠ˜
            if(_segmentPenNum<=0 and _segmentPenNum<5 )
                isCreateStrategy := false
        //2ä¹°å–
        if(_operatePoint.typeNum==2 and p_strategy_two)
            Pivot _lastPivot = na
            if( na(_preSegment) )
                isCreateStrategy := false  
            else
                //åˆ¤æ–­æ˜¯å¦æœ‰é’ˆå¯¹ä¸­æ¢çš„ä¸‰ä¹°å–
                if(na(_prePen))
                    isCreateStrategy := false
                else
                    if(_segment.direction == 1 and _prePen.low > _segment.high)
                        isCreateStrategy := false
                    else if(_segment.direction == -1 and _prePen.high < _segment.low)
                        isCreateStrategy := false
            //print(str.tostring(isCreateStrategy)+"=="+str.tostring(strategy.equity))
        //ä¹°å–è®¢å•åç¼€idï¼Œå¦‚ä¹°å…¥ buy_1 å–å‡º sell_2
        string id = ""
        string _id_suffix =  str.tostring(array.indexof(_pens,_pen)+1)+"_"+str.tostring(math.round(math.random(1,100,0)))
        string comments = ""
        if(isCreateStrategy)
            if(_operatePoint.operateType == 1)
                id := "buy_"+_id_suffix
                //å–å¾—æ­¢æŸä»·æ ¼,è¯¥ç¬”æœ€ä½ç‚¹è®¾ç½®ä¸ºæ­¢æŸä»·æ ¼
                float _stopPrice = _pen.low
                float _getPrice = close[0]//array.get(_pen.mergeHigh,array.size(_pen.mergeHigh)-1)
                // if(strategy.equity>0)
                    //comments := "id:"+id+"\nä¹°å…¥ä»·ä½"+str.tostring(_getPrice)+"id:"+id+"\næ­¢æŸä»·ä½:"+str.tostring(_stopPrice)
                strategy.entry(id,strategy.long,comment = "å¤š:id:"+str.tostring(id)+"\næ­¢æŸä»·ä½:"+str.tostring(_stopPrice))
                    //print("å¤š:"+str.tostring(open[0])+"\næ­¢æŸ:"+str.tostring(_stopPrice))
                    //strategy.exit(id+"_exit",id,limit =_stopPrice,comment = "å¤š:id:"+str.tostring(id)+"\næ­¢æŸä»·ä½:"+str.tostring(_stopPrice) )
                    //strategy.exit(id+"_exit",id,limit =_stopPrice)
                strategy.exit(id+"_stop",id ,stop =_stopPrice)   
            else if(_operatePoint.operateType == -1)
                id := "sell_"+_id_suffix
                //å–å¾—æ­¢æŸä»·æ ¼,è¯¥ç¬”æœ€é«˜ç‚¹è®¾ç½®ä¸ºæ­¢æŸä»·æ ¼
                float _stopPrice = _pen.high
                float _getPrice = close[0]//array.get(_pen.mergeLow,array.size(_pen.mergeLow)-1)
                if(strategy.equity>0)
                    //comments := "id:"+id+"\nå–å‡ºä»·ä½"+str.tostring(_getPrice)+"\æ­¢æŸä»·ä½:"+str.tostring(_stopPrice)
                    strategy.entry(id,strategy.short ,comment = "ç©º:id:"+str.tostring(id)+"\næ­¢æŸä»·ä½:"+str.tostring(_stopPrice))
                    //print("ç©º:"+str.tostring(open[0])+"\næ­¢æŸ:"+str.tostring(_stopPrice))
                    //strategy.exit(id+"_exit",id,limit =_stopPrice ,comment = "ç©º:id:"+str.tostring(id)+"\næ­¢æŸä»·ä½:"+str.tostring(_stopPrice))
                    //strategy.exit(id+"_exit",id,limit =_stopPrice)
                    strategy.exit(id+"_stop",id ,stop =_stopPrice)
//æ£€æµ‹éªŒè¯1ä¹°å–ç‚¹
checkOneOperate(int _gradeNum,Segment _segment,Pen _checkPen,Pen[] _needDrawPens)=>
    Pen[] _pens= getGradePens(_gradeNum)
    Pen _lastPen = _checkPen
    int _direction = _segment.direction
    //å†æ¬¡åˆ¤æ–­å‡ºä¸­æ¢è¿™ç¬” å’Œ è¿›ä¸­æ¢ç¬” æ˜¯å¦èƒŒé©°
    Pen _pivotStartPen = array.get(_pens,_segment.startPenIndex)
    //åˆ¤æ–­å‰é¢æ˜¯å¦æœ‰ä¸­æ¢
    Pivot _prePivot = getLastPivotByPen(_gradeNum,_lastPen)
    if(not na(_prePivot))
        if(_prePivot.endPenIndex == array.indexof(_pens,_lastPen))
            _pivotStartPen :=  array.get(_pens,_prePivot.startPenIndex)
        else
            _pivotStartPen :=  array.get(_pens,_segment.endPenIndex-2)
    if(_lastPen.high-_lastPen.low < _pivotStartPen.high-_pivotStartPen.low  and filterOperate(_gradeNum,_segment,_lastPen))
        OperatePoint _operatePoint =OperatePoint.new(-_direction,1,_direction==1?_lastPen.high:_lastPen.low,"")
        bool isAlert = false
        //åªæœ‰æœ€åä¸€ç¬”ï¼Œå¹¶ä¸”ä¹‹å‰æ²¡æœ‰ä¹°å–ç‚¹ï¼Œæˆ–è€…ä¹‹å‰æœ‰ä¹°å–ç‚¹ä½†ä»·æ ¼å‘ç”Ÿå˜åŒ–æ‰è¿›è¡ŒæŠ¥è­¦
        if(array.indexof(_pens,_lastPen) == array.size(_pens)-1)
            if(na(_lastPen.operatePoint))
                isAlert := true
            else
                if(_operatePoint.price != _lastPen.operatePoint.price)
                    isAlert := true
        if(not na(_lastPen.operatePoint))
            //if(_lastPen.operatePoint.price != _operatePoint.price)
            delDrawPenOperate(_gradeNum ,_lastPen)
            //ç»˜åˆ¶èƒŒé©°ä½ç½®
            //label.new(_lastPen.endTime,_lastPen.direction==1?_lastPen.high:_lastPen.low,style = label.style_cross,xloc = xloc.bar_time,yloc = yloc.price,size = size.tiny)
        _lastPen.operatePoint := _operatePoint
        array.push(_needDrawPens,_lastPen)
        //è®¾ç½®æŠ¥è­¦æ ‡å¿—
        if(isAlert)
            setAlertFlag(_gradeNum,_operatePoint)
        if(p_strategy_one)
            strategyCreate( _gradeNum, _segment, _checkPen,_operatePoint)
//æ£€æµ‹éªŒè¯2ä¹°å–ç‚¹
checkTwoOperate(int _gradeNum,Segment _segment,Pen _pen,Pen[] _needDrawPens,int stype)=>
    Pen[] _pens= getGradePens(_gradeNum)
    //çº¿æ®µå¯¹åº”çš„æ–¹å‘
    int _direction = _segment.direction
    OperatePoint _operatePoint = na
    if(_pen.direction != _direction)
        _operatePoint := OperatePoint.new(_direction,stype,_direction==1?_pen.low:_pen.high,"")
    else
        Pen _prePen = array.get(_pens,_segment.endPenIndex)
        if(_direction == 1)
            if(_pen.high < _prePen.high)
                _operatePoint := OperatePoint.new(-_direction,stype,_pen.high,"")
        if(_direction == -1)
            if(_pen.low > _prePen.low)
                _operatePoint := OperatePoint.new(-_direction,stype,_pen.low,"")
    //å¦‚æœæ˜¯ç¬”ä¸­æ¢è¯
    if(not na(_operatePoint))
        if(filterOperate(_gradeNum,_segment,_pen))
            bool isAlert = false
            //åªæœ‰æœ€åä¸€ç¬”ï¼Œå¹¶ä¸”ä¹‹å‰æ²¡æœ‰ä¹°å–ç‚¹ï¼Œæˆ–è€…ä¹‹å‰æœ‰ä¹°å–ç‚¹ä½†ä»·æ ¼å‘ç”Ÿå˜åŒ–æ‰è¿›è¡ŒæŠ¥è­¦
            if(array.indexof(_pens,_pen) == array.size(_pens)-1)
                if(na(_pen.operatePoint))
                    isAlert := true
                else
                    if(_operatePoint.price != _pen.operatePoint.price)
                        isAlert := true
            if(not na(_pen.operatePoint))
                //if(_pen.operatePoint.price != _operatePoint.price)
                delDrawPenOperate(_gradeNum ,_pen)
            _pen.operatePoint := _operatePoint
            array.push(_needDrawPens,_pen)
            //print("isAlert:"+str.tostring(isAlert))
            //è®¾ç½®æŠ¥è­¦æ ‡å¿—
            if(isAlert)
                setAlertFlag(_gradeNum,_operatePoint)
            if(p_strategy_two and stype == 2)
                strategyCreate( _gradeNum, _segment, _pen,_operatePoint)
            if(p_strategy_two_lei and stype == -2)
                strategyCreate( _gradeNum, _segment, _pen,_operatePoint)  
//æ£€æµ‹éªŒè¯3ä¹°å–ç‚¹
checkThreeOperate(int _gradeNum,Segment _segment,Pen _pen,Pen[] _needDrawPens)=>
    Pen[] _pens= getGradePens(_gradeNum)
    //å½“å‰ç¬”index
    int i = array.indexof(_pens,_pen)
    //çº¿æ®µå¯¹åº”çš„æ–¹å‘
    int _direction = _segment.direction
    Pen _preDirectionPen = array.get(_pens,i-2)
    float _price = (_direction == 1 and _pen.low > _preDirectionPen.high) ? _pen.low : (_direction == -1 and _pen.high <  _preDirectionPen.low) ? _pen.high : -1
    //åˆ¤æ–­å’Œä¸Šç¬”åŒæ–¹å‘çš„æ˜¯å¦æœ‰ç¼ºå£
    // if(_direction == 1 and _pen.low > _preDirectionPen.high)
    //     _price := _pen.low
    // if(_direction == -1 and _pen.high <  _preDirectionPen.low)
    //     _price := _pen.high
    //ä¸å­˜åœ¨ç¼ºå£çš„è¯å†åˆ¤æ–­å‰é¢æ˜¯å¦æœ‰ä¸­æ¢ï¼Œå¹¶ä¸”ä¸åœ¨ä¸­æ¢èŒƒå›´ä¸­
    if(_price == -1)
        //åˆ¤æ–­å‰é¢æ˜¯å¦æœ‰ä¸­æ¢
        Pivot _prePivot = getLastPivotByPen(_gradeNum,_pen)
        //å­˜åœ¨ä¸­æ¢çš„è¯ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯å‡ºä¸­æ¢ç¬¬ä¸€ç¬”
        if(not na(_prePivot))
            if(i == _prePivot.endPenIndex+1)
                if(_direction == 1 and _pen.low > _prePivot.high)
                    _price := _pen.low
                if(_direction == -1 and _pen.high <  _prePivot.low)
                    _price := _pen.high
    if(_price != -1 and filterOperate(_gradeNum,_segment,_pen))
        OperatePoint _operatePoint =OperatePoint.new(_direction,3,_price,"")
        bool isAlert = false
        //åªæœ‰æœ€åä¸€ç¬”ï¼Œå¹¶ä¸”ä¹‹å‰æ²¡æœ‰ä¹°å–ç‚¹ï¼Œæˆ–è€…ä¹‹å‰æœ‰ä¹°å–ç‚¹ä½†ä»·æ ¼å‘ç”Ÿå˜åŒ–æ‰è¿›è¡ŒæŠ¥è­¦
        if(array.indexof(_pens,_pen) == array.size(_pens)-1)
            if(na(_pen.operatePoint))
                isAlert := true
            else
                if(_operatePoint.price != _pen.operatePoint.price)
                    isAlert := true
        if(not na(_pen.operatePoint))
            //if(_pen.operatePoint.price != _operatePoint.price)
            delDrawPenOperate(_gradeNum ,_pen)
        _pen.operatePoint := _operatePoint
        array.push(_needDrawPens,_pen)
        //è®¾ç½®æŠ¥è­¦æ ‡å¿—
        // if(isAlert)
        //     setAlertFlag(_gradeNum,_operatePoint)
        if(p_strategy_three)
            strategyCreate( _gradeNum, _segment, _pen,_operatePoint)
//@function ç¬”å¯¹åº”çš„ä¹°å–ç‚¹æ“ä½œ
//@param _gradeNum:æŒ‡å®šçº§åˆ«çš„ç¬”
//@param _pen:ç¬”å¯¹è±¡
penOperateHandler(int _gradeNum)=>
    Segment[] _segments = getGradeSegments(_gradeNum)
    Pen[] _pens= getGradePens(_gradeNum)

    //å–å¾—è¯¥ç¬”å¯¹åº”çš„çº¿æ®µä¿¡æ¯,å¦‚æœä¸å±äºä»»ä½•çº¿æ®µæµ‹å…ˆé»˜è®¤æ˜¯å±äºæœ€åä¸€ä¸ªçº¿æ®µ
    Segment _operateSegament =  na
    if(array.size(_segments)>0)
        _operateSegament :=  array.get(_segments,array.size(_segments)-1)
    //æ˜¯å¦èµ°ä¹°å–ç‚¹é€»è¾‘
    bool isCycOperatePoint = false
    if(not na(_operateSegament))
        //æœ‰çº¿æ®µï¼Œå¹¶ä¸”æœ€åçº¿æ®µä¸èƒ½æ˜¯1ç¬”æˆæ®µçš„
        if(_operateSegament.endPenIndex - _operateSegament.startPenIndex>=2)
            isCycOperatePoint := true
    if(isCycOperatePoint)
        Pivot[]   _OperatePivots =  _operateSegament.pivots
        //çº¿æ®µå¯¹åº”çš„æ–¹å‘
        int _direction = _operateSegament.direction
        int _signNum = 0
        //ä¿å­˜æ‰€æœ‰éœ€è¦ç»˜åˆ¶çš„ä¹°å–ç‚¹
        Pen[] _needDrawPens = array.new<Pen>()
        //é¦–å…ˆæ¸…é™¤æœ€åçº¿æ®µåŠç¬”çš„ä¹°å–ç‚¹ä¿¡æ¯
        // for int i= _operateSegament.startPenIndex to array.size(_pens)-1
        //     Pen _pen = array.get(_pens,i)
        //     delDrawPenOperate(_gradeNum,_pen)
        //å¯¹åœ¨çº¿æ®µå†…çš„ç¬”ä¹°å–ç‚¹å¤„ç†
        for int i= _operateSegament.startPenIndex to array.size(_pens)-1
            _signNum += 1
            //å¯¹åº”penä¿¡æ¯
            Pen _pen = array.get(_pens,i)
            //å’Œçº¿æ®µä¸åŒå‘åˆ¤æ–­2,3ä¹°å–ç‚¹
            if(_pen.direction != _direction)
                //å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åå‘çš„è¯å¹¶ä¸”æå€¼ä¸è¶…è¿‡å‰ä¸€ç¬”è®¤å®šä¸º2ä¹°å–ç‚¹
                if(_signNum == 2)
                    checkTwoOperate(_gradeNum,_operateSegament,_pen,_needDrawPens,2)
                else if(_signNum == 4  )
                    Pen _preDirectionPen = array.get(_pens,i-2)
                    float _price = -1
                    //åˆ¤æ–­å’Œä¸Šç¬”åŒæ–¹å‘çš„æ˜¯å¦æœ‰ç¼ºå£
                    if(_direction == 1 and _pen.low > _preDirectionPen.high)
                        _price := _pen.low
                    if(_direction == -1 and _pen.high <  _preDirectionPen.low)
                        _price := _pen.high
                    if(_price==-1)
                        checkTwoOperate(_gradeNum,_operateSegament,_pen,_needDrawPens,-2)
                    else
                        checkThreeOperate(_gradeNum,_operateSegament,_pen,_needDrawPens)
                else if(_signNum % 2 == 0 and i!=0)
                    checkThreeOperate(_gradeNum,_operateSegament,_pen,_needDrawPens)
            //å’Œçº¿æ®µåŒå‘æ—¶å€™
            else
                //çº¿æ®µæœ€åä¸€ç¬” 1ä¹°å–(å¹¶ä¸”è¯¥çº¿æ®µè‡³å°‘è¦æœ‰ä¸€ä¸ªä¸­æ¢)
                if(i == _operateSegament.endPenIndex and array.size(_operateSegament.pivots)>=1)
                    //å†æ¬¡åˆ¤æ–­å‡ºä¸­æ¢è¿™ç¬” å’Œ è¿›ä¸­æ¢ç¬” æ˜¯å¦èƒŒé©°
                    checkOneOperate(_gradeNum,_operateSegament,_pen,_needDrawPens)
                else if(i == _operateSegament.endPenIndex+2)
                    checkTwoOperate(_gradeNum,_operateSegament,_pen,_needDrawPens,2)
                else if(i == _operateSegament.endPenIndex+4)//ç±»2
                    checkTwoOperate(_gradeNum,_operateSegament,_pen,_needDrawPens,-2)
        //å¯¹ä¹°å–ç‚¹è¿›è¡Œç»˜åˆ¶
        for int i= _operateSegament.startPenIndex to array.size(_pens)-1
            Pen _pen = array.get(_pens,i)
            if(array.indexof(_needDrawPens,_pen)!=-1)
                drawPenOperate(_gradeNum,_pen)
            else
                delDrawPenOperate(_gradeNum,_pen)
//#endregion
//#region @function æ„å»ºä¸­æ¢ç›¸å…³å‡½æ•°
// //æå‰ç»˜åˆ¶ä¸­æ¢ï¼Œä»…ä¾›æ˜¾ç¤ºä½¿ç”¨
// beforeDrawPivot(int _gradeNum) =>
//     //å–å¾—çº§åˆ«å¯¹åº”çš„ä¸­æ¢
//     Segment[] _segments = getGradeSegments(_gradeNum)
//     //å–å¾—æœ€åä¸€ä¸ªçº¿æ®µ
//     Segment _lastSegment = na
//     //çº¿æ®µæœ€åä¸€ä¸ªä¸­æ¢
//     Pivot   _lastPivot = na
//     if(array.size(_segments) > 0 )
//         _lastSegment  := array.last(_segments)
//     if(not na(_lastSegment))
//         //åˆ¤æ–­è¯¥çº¿æ®µæ˜¯å¦æœ‰ä¸­æ¢,å¦‚æœæœ‰ä¸­æ¢çš„è¯è·å¾—æœ€åä¸€ä¸ªä¸­æ¢
//         if(array.size(_lastSegment.pivots)>0)
//             _lastPivot := array.last(_lastSegment.pivots)
//     //å­˜åœ¨ä¸­æ¢çš„è¯ç›´æ¥æ‰©å±•ä¸­æ¢åˆ°å½“å‰æ—¶é—´
//     if(not na(_lastPivot))
//         box _box = _lastPivot.box
//         if(high > box.get_bottom(_box) and low < box.get_top(_box))
//             box.set_right(_box,time)

//ç»™æŒ‡å®šçº¿æ®µæ„å»ºå‡ºä¸€ä¸ªä¸­æ¢
checkHaveNewPivot(int _gradeNum,Segment _segment,Pen[] _pens) =>
    //çº¿æ®µæ–¹å‘
    int _direction = _segment.direction
    int _startPenIndex = _segment.startPenIndex + 1
    Pivot _lastPivot = na
    if(array.size(_segment.pivots)>0)
        _lastPivot := array.last(_segment.pivots)
        _startPenIndex := _lastPivot.endPenIndex + 1
        // if(_gradeNum == 1)
        //     print(":"+str.tostring(_startPenIndex))
    //å¯èƒ½æ„å»ºæ–°çš„ä¸­æ¢
    Pivot _pivot = na
    //èµ·å§‹åå‘ç¬”
    Pen _startPen = na
    for _checkSegmentIndex =_startPenIndex to array.size(_pens) -1  by 2
        if(_checkSegmentIndex > array.size(_pens) -1)
            break
        Pen _tempPen = array.get(_pens,_checkSegmentIndex)
        if(na(_startPen))
            _startPen := _tempPen
        else
            //å¦‚æœå½“å‰ç¬”åœ¨å‰ä¸€ä¸ªä¸­æ¢çš„è¯ç›´æ¥è·³è¿‡
            if(not na(_lastPivot))
                if(_startPen.high >= _lastPivot.low and _startPen.low <= _lastPivot.high )
                    continue
            float _minHighPrice = math.min( _tempPen.high,_startPen.high)
            float _maxLowPrice = math.max(_tempPen.low,_startPen.low)
            if( _minHighPrice > _maxLowPrice)
                //ä¸­é—´ç¬”
                Pen _middlePen = array.get(_pens,_checkSegmentIndex - 1)
                float _minPrice = math.max(_startPen.low,_tempPen.low,_middlePen.low)
                float _maxPrice = math.min(_startPen.high,_tempPen.high,_middlePen.high)
                _pivot := Pivot.new(_maxPrice,_minPrice,_startPen.startTime,_tempPen.endTime,_checkSegmentIndex,_checkSegmentIndex+4,_segment.direction,1)
                break
            else
                _startPen := _tempPen
    _pivot
//æ¸…ç†æå‰ç»˜åˆ¶çš„ä¸­æ¢
clearBeforeDrawPivot(int _gradeNum) =>
    Grade _grade = array.get(grades,_gradeNum)
    box _pivotBeforeDrawBox = _grade.pivotBeforeDrawBox
    box.set_right(_pivotBeforeDrawBox,na)
    box.set_left(_pivotBeforeDrawBox,na)
//æå‰ç»˜åˆ¶ä¸­æ¢ï¼Œä»…ä¾›æ˜¾ç¤ºä½¿ç”¨,ç”¨äºæœ€è¿‘ä¸­æ¢çš„å±•ç¤ºä»¥åˆ¤æ–­æ”¯æŒå‹åŠ›
beforeDrawPivot(int _gradeNum) =>
    Grade _grade = array.get(grades,_gradeNum)
    box minPivotBeforeDrawBox  = _grade.pivotBeforeDrawBox
    Pen[] _pens= getGradePens(_gradeNum)
    //å–å¾—çº§åˆ«å¯¹åº”çš„çº¿æ®µ
    Segment[] _segments = getGradeSegments(_gradeNum)
    //å–å¾—æœ€åä¸€ä¸ªçº¿æ®µ
    Segment _lastSegment = (array.size(_segments) > 0 ) ? array.last(_segments) : na
    Segment _preSegment = (array.size(_segments) > 1 )  ? array.get(_segments,array.size(_segments) - 2) : na
    //çº¿æ®µæœ€åä¸€ä¸ªä¸­æ¢
    Pivot   _lastPivot = na
    if(not na(_lastSegment))
        //åˆ¤æ–­è¯¥çº¿æ®µæ˜¯å¦æœ‰ä¸­æ¢,å¦‚æœæœ‰ä¸­æ¢çš„è¯è·å¾—æœ€åä¸€ä¸ªä¸­æ¢
        if(array.size(_lastSegment.pivots)>0)
            _lastPivot := array.last(_lastSegment.pivots)
        //åˆ¤æ–­æ˜¯å¦å¯ä»¥ç»˜åˆ¶æ–°çš„ä¸­æ¢
        Pivot _newPivot =  checkHaveNewPivot(_gradeNum,_lastSegment,_pens)
        if(not na(_newPivot))
            _lastPivot := _newPivot
        //å¦‚æœæœ€ç»ˆè¿˜æ˜¯ä¸ºna,é‚£ä¹ˆå¯¹æœ€åä¸¤ä¸ªçº¿æ®µç¬”è¿›è¡Œå¤„ç†æ‹æ®µæ˜¯å¦æœ‰ä¸­æ¢
        if(na(_lastPivot) and not na(_preSegment))
            _lastPivot :=  checkHaveNewPivot(_gradeNum,_preSegment,_pens)
        //å­˜åœ¨ä¸­æ¢çš„è¯ç›´æ¥æ‰©å±•ä¸­æ¢åˆ°å½“å‰æ—¶é—´
        if(not na(_lastPivot))
            if(high >= _lastPivot.low or low <= _lastPivot.high)
                color _bgcolor =_lastPivot.direction == 1?_grade.pivotUpBgColor:_grade.pivotDownBgColor
                // box.set_bgcolor(minPivotBeforeDrawBox,_bgcolor)
                // box.set_border_color(minPivotBeforeDrawBox,_lastPivot.direction == 1?_grade.pivotUpBorderColor:_grade.pivotDownBordeColor)
                box.set_bgcolor(minPivotBeforeDrawBox,color = color.rgb(126, 123, 123, 95))
                box.set_border_color(minPivotBeforeDrawBox,_lastPivot.direction == 1?_grade.pivotUpBorderColor:_grade.pivotDownBordeColor)
                box.set_lefttop(minPivotBeforeDrawBox,_lastPivot.startTime,_lastPivot.high)
                if(minPivotBeforeDrawBox.get_top() == _lastPivot.high and minPivotBeforeDrawBox.get_left() == _lastPivot.startTime)
                    box.set_rightbottom(minPivotBeforeDrawBox,time,_lastPivot.low)
    1
//ç»™æŒ‡å®šçº¿æ®µæ„å»ºä¸­æ¢
delPivot(int _gradeNum,Pivot _pivot,Segment _segment) =>
    //ç§»é™¤ä¸­æ¢æ˜¾ç¤º
    box.delete(_pivot.box)
    //array.remove(_segment.pivots,array.indexof(_segment.pivots,_pivot))
drawPivot(int _gradeNum,Pivot _pivot,Segment _segment) =>
    Grade _grade = array.get(grades,_gradeNum)
    Pivot[] _pivots = _segment.pivots
    //æ²¡æœ‰boxå°±å…ˆåˆ›å»º
    bool isShowPivot = (_gradeNum == 1 and not p_showPenPivot) ? false :(_gradeNum == 1 and not p_showPenPivot) ? false : true
    // if(_gradeNum == 1 and not p_showPenPivot)
    //     isShowPivot := false
    // if(_gradeNum > 1 and not p_showPivot)
    //     isShowPivot := false
    if(isShowPivot)
        box _box = _pivot.box
        if(na(_box))
            //å¦‚æœä¸­æ¢å‘ç”Ÿæ‰©å±•å»¶ä¼¸
            if(_pivot.endPenIndex - _pivot.startPenIndex+1 >= 9+2 and _gradeNum == 1)
                _box := box.new(_pivot.startTime,_pivot.high,_pivot.endTime,_pivot.low,xloc = xloc.bar_time
                                      ,bgcolor = _pivot.direction == 1?penExtendPivotUpBgColor:penExtendPivotDownBgColor
                                      ,border_color = _pivot.direction == 1?penExtendPivotUpBorderColor:penExtendPivotDownBorderColor)
            else
                _box := box.new(_pivot.startTime,_pivot.high,_pivot.endTime,_pivot.low,xloc = xloc.bar_time
                                     ,bgcolor = _pivot.direction == 1?_grade.pivotUpBgColor:_grade.pivotDownBgColor
                                     ,border_color = _pivot.direction == 1?_grade.pivotUpBorderColor:_grade.pivotDownBordeColor)
            _pivot.box  := _box
        box.set_rightbottom(_box,_pivot.endTime, _pivot.low )
        if(_pivot.endPenIndex - _pivot.startPenIndex+1 >= 9+2)
            box.set_bgcolor(_box,_pivot.direction == 1?penExtendPivotUpBgColor:penExtendPivotDownBgColor)
            box.set_border_color(_box, _pivot.direction == 1?penExtendPivotUpBorderColor:penExtendPivotDownBorderColor)
    if(array.indexof(_pivots,_pivot) <= -1)
        //å°†ä¸­æ¢åŠ å…¥é›†åˆä¸­
        //print("direction"+str.tostring(_pivot.direction))
        array.push(_pivots,_pivot)

//æ ¹æ®çº¿æ®µæ„å»ºä¸­æ¢       
createPivot(int _gradeNum,Segment _segment,Pen[] _pens) =>
    //ä¸­é€”ä¿®å¤ï¼Œæ¯æ¬¡é‡æ–°æ„å»ºè¯¥çº¿æ®µä¸­æ¢
    if(array.size(_segment.pivots)>0)
        for i=0 to array.size(_segment.pivots)-1
            delPivot(_gradeNum,array.get(_segment.pivots,i),_segment)
        _segment.pivots := array.new<Pivot>()
    Grade _grade = array.get(grades,_gradeNum)
    //å–å¾—è¯¥çº¿æ®µæœ€åçš„ä¸­æ¢
    Pivot _lastPivot = na
    int _startPenIndex = _segment.startPenIndex
    int _endPenIndex   = _segment.endPenIndex
    // = str.tostring(_startPenIndex)+":"+str.tostring(_endPenIndex)
    //string ini1 = ""
    if(array.size(_segment.pivots)>0)
        _lastPivot := array.get(_segment.pivots,array.size(_segment.pivots)-1)
        _startPenIndex :=  _lastPivot.endPenIndex
        //ini1 := "**:"+str.tostring(_startPenIndex)+":"+str.tostring(_endPenIndex)
        //debugInfo.debugInfo += "\nstartPenIndex:"+str.tostring(_startPenIndex)+"\n _endPenIndex:"+str.tostring(_endPenIndex)
    //debugInfo.debugInfo +="\npivotsize:"+str.tostring(array.size(_segment.pivots))+"\n_startPenIndex:"+str.tostring(_startPenIndex)
    for _checkSegmentIndex =_startPenIndex to _endPenIndex
        if(_checkSegmentIndex < _startPenIndex)
            continue
        if(_startPenIndex > _endPenIndex)
            continue
        //éªŒè¯åç»­æ˜¯å¦æˆä¸­æ¢
        bool isExtend = false
        // if(array.size(_pens)==879)
        //     runtime.error(ini+"==="+ini1+" å‡ºç°879:"+str.tostring(_startPenIndex)+":"+str.tostring(_endPenIndex))
        //5ç¬”ä¿¡æ¯
        Pen _pen1 = array.get(_pens,_checkSegmentIndex+0)
        Pen _pen2 = na
        if(_checkSegmentIndex+1<=_endPenIndex)
            _pen2 := array.get(_pens,_checkSegmentIndex+1)
        Pen _pen3 = na
        if(_checkSegmentIndex+2<=_endPenIndex)
            _pen3 := array.get(_pens,_checkSegmentIndex+2)
        Pen _pen4 = na
        if(_checkSegmentIndex+3<=_endPenIndex)
            _pen4 := array.get(_pens,_checkSegmentIndex+3)
        Pen _pen5 = na
        if(_checkSegmentIndex+4<=_endPenIndex)
            _pen5 := array.get(_pens,_checkSegmentIndex+4)
        //åˆ¤æ–­ä¹‹å‰å¦‚æœæœ‰ä¸­æ¢çš„è¯ï¼Œå¹¶ä¸”è¯¥ç¬”åœ¨ä¸­æ¢å†…å°±å»¶ä¼¸ä¸­æ¢
        if(not na(_lastPivot) ) //and _startPenIndex != _checkSegmentIndex
            //if(_lastPivot.direction != _pen1.direction)
            //å–å¾—çº¿æ®µå¯¹åº”çš„æœ€åä¸€ç¬”
            //Pen _lastPen = array.get(_pens,_segment.endPenIndex)
            //åˆ¤æ–­è¯¥ç¬”æ˜¯å¦åœ¨ä¸­æ¢èŒƒå›´ä¸­ï¼Œåœ¨èŒƒå›´ä¸­çš„è¯å°±å»¶ç»­ä¸­æ¢
            //print("\ndirection:"+str.tostring(_pen1.direction !=_lastPivot.direction))
            if (  not na(_pen2) and  _lastPivot.state ==1) //_pen1.direction !=_lastPivot.direction and
                if(_pen2.high > _lastPivot.low and _pen2.low < _lastPivot.high)
                    _lastPivot.endTime :=_pen2.endTime 
                    _lastPivot.endPenIndex := array.indexof(_pens,_pen2)+1
                    drawPivot(_gradeNum,_lastPivot,_segment)
                    isExtend  := true
                else
                    _lastPivot.state :=2
            if (  not na(_pen4) and  _lastPivot.state ==1) //_pen1.direction !=_lastPivot.direction and
                if(_pen4.high > _lastPivot.low and _pen4.low < _lastPivot.high)
                    _lastPivot.endTime :=_pen4.endTime 
                    _lastPivot.endPenIndex := array.indexof(_pens,_pen4)+1
                    drawPivot(_gradeNum,_lastPivot,_segment)
                    isExtend  := true
                else
                    _lastPivot.state :=2
        //debugInfo.debugInfo+="\nisExtend:"+str.tostring(isExtend)+"\n _checkSegmentIndex:"+str.tostring(_checkSegmentIndex)+"\n_endPenIndex:"+str.tostring(_endPenIndex)
        // if(_endPenIndex == 799)
        //     print(debugInfo.debugInfo)
        //     break
        //æ²¡æœ‰å»¶ç»­çš„è¯å†åˆ¤æ–­è‡³å°‘æœ‰5ç¬”é‡å æ‰èƒ½æ„æˆä¸­æ¢
        if( not isExtend and _checkSegmentIndex+4<=_endPenIndex)
            // _pen2 = array.get(_pens,_checkSegmentIndex+1)
            // _pen3 = array.get(_pens,_checkSegmentIndex+2)
            // _pen4 = array.get(_pens,_checkSegmentIndex+3)
            // _pen5 = array.get(_pens,_checkSegmentIndex+4)
            float _minPrice = math.max(_pen1.low,_pen2.low,_pen3.low,_pen4.low,_pen5.low)
            float _maxPrice = math.min(_pen1.high,_pen2.high,_pen3.high,_pen4.high,_pen5.high)
            bool _hasInclude = _maxPrice > _minPrice
            //debugInfo.debugInfo +="\pen1.high:"+str.tostring(_pen1.high)+"\n_pen1.low:"+str.tostring(_pen1.low)
            _hasInclude :=_hasInclude and _pen1.high >= _maxPrice and _pen1.low <= _minPrice
            _hasInclude :=_hasInclude and _pen2.high >= _maxPrice and _pen2.low <= _minPrice
            _hasInclude :=_hasInclude and _pen3.high >= _maxPrice and _pen3.low <= _minPrice
            _hasInclude :=_hasInclude and _pen4.high >= _maxPrice and _pen4.low <= _minPrice
            _hasInclude :=_hasInclude and _pen5.high >= _maxPrice and _pen5.low <= _minPrice
            //debugInfo.debugInfo +="\_hasInclude:"+str.tostring(_hasInclude)
            if(_hasInclude)
                //debugInfo.debugInfo +="\n_pen2.low:"+str.tostring(_pen2.low)+"\n_pen3.low:"+str.tostring(_pen3.low)+"\n_pen4.low:"+str.tostring(_pen4.low)
                _minPrice := math.max(_pen2.low,_pen3.low,_pen4.low)
                _maxPrice := math.min(_pen2.high,_pen3.high,_pen4.high)
                //debugInfo.debugInfo += "\n_minPrice:"+str.tostring(_minPrice)+"\n_maxPrice:"+str.tostring(_maxPrice)
                //print(debugInfo.debugInfo)
                Pen _lastPen =  array.get(_pens,array.size(_pens)-1)
                Pivot _pivot = Pivot.new(_maxPrice,_minPrice,_pen1.endTime,_pen5.startTime,_checkSegmentIndex,_checkSegmentIndex+4,_segment.direction,1)
                // debugInfo.debugInfo +="\n_minPrice:"+str.tostring(_minPrice)+"\n_maxPrice:"+str.tostring(_maxPrice)
                //      +"\n_checkSegmentIndex:"+str.tostring(_checkSegmentIndex)+"\n"
                //print(debugInfo.debugInfo)
                drawPivot(_gradeNum,_pivot,_segment)
                //print("\n------------------------------------"+str.tostring(array.size(_segment.pivots)))
        // else
        //     print(debugInfo.debugInfo)
        //ä¸ºå•¥è¿™æ ·å†™ï¼Œè¯´äº†ä½ åˆä¸æ‡‚,ä¹Ÿè®¸ä½ ä»¥ä¸ºä½ æ‡‚äº†ï¼Œä½†ä½ å…¶å®å•¥éƒ½ä¸æ‡‚
        if(array.size(_segment.pivots)>0)
            _lastPivot := array.get(_segment.pivots,array.size(_segment.pivots)-1)
            _startPenIndex :=  _lastPivot.endPenIndex
    // if(_gradeNum == 1)
    //     print(debugInfo.debugInfo)





//#endregion

//#region æ„å»ºçº¿æ®µ
//ç§»é™¤çº¿æ®µ
delSegment(int _gradeNum,Segment[] _segments,Pen[] _selfPens,Segment _segment) =>
    clearBeforeDrawPivot(_gradeNum)
    if(array.indexof(_segments,_segment) >= 0)
        Grade _grade = array.get(grades,_gradeNum)
        Pen[] _pens= getGradePens(_gradeNum)
        line.delete(_segment.line)
        //ç§»é™¤å¯¹åº”ä¸­æ¢æ˜¾ç¤º
        for i = 0 to (array.size(_segment.pivots) >0? array.size(_segment.pivots)-1: na)
            delPivot(_gradeNum,array.get(_segment.pivots,i),_segment)
        array.remove(_segments,array.indexof(_segments,_segment))
        //ç§»é™¤æ¨¡æ‹Ÿæ„å»ºçš„ç¬”
        if(not na(_selfPens) and array.indexof(_selfPens,_segment.pen)>0)
            //print("index:"+str.tostring(array.indexof(_selfPens,_segment.pen))+"\n size:"+str.tostring(array.size(_selfPens)))
            delDrawPenOperate(_gradeNum,_segment.pen)
            array.remove(_selfPens,array.indexof(_selfPens,_segment.pen))
        if(array.size(_segments)>0)
            Segment _preSegment = array.get(_segments,array.size(_segments)-1)
            _preSegment.segmentState := 1
            line.set_style(_preSegment.line,line.style_dashed)

//æ®µmacdæ˜¾ç¤ºåŠå¤„ç†(åªå¤„ç†æœ€åä¸€æ®µ)
segementMacdHandler(int _gradeNum,Segment _segment)=>
    Grade _grade = array.get(grades,_gradeNum)
    Pen[] _pens= getGradePens(_gradeNum)
    Pen _pen = array.last(_pens)
    //æ¯”å¯¹çš„ç¬”
    Pen _comparePen = na
    //ç¬”å†…éƒ¨æ˜¯å¦èƒŒé©°
    bool _penInnerError = false
    //è¿›å‡ºæ®µæ˜¯å¦èƒŒé©°
    bool _segmentError = false
    //åˆ¤æ–­ç¬”å†…éƒ¨æ˜¯å¦èƒŒé©°
    if(_gradeNum == 1)
        //åˆ¤æ–­ä¸€ç¬”é¢ç§¯ä¸­æ˜¯å¦ä¸­é—´æœ‰ç»å†é‡‘æ­»å‰
        if(_pen.direction == 1 and array.size(_pen.area)>0)
            //print("_pen.area:"+str.tostring(array.last(_pen.area))+"\nareas:"+str.tostring(_pen.area))
            //åˆ¤æ–­æ˜¯å¦å‘ç”Ÿé‡‘å‰
            float _maxArea = array.max(_pen.area)
            float _minArea = array.min(_pen.area)
            bool _hasCoss = false
            //å‘ç”Ÿé‡‘å‰çš„è¯åˆ¤æ–­ä¹‹å‰<0çš„æœ€é«˜ç»å¯¹å€¼
            float _tempPice = math.abs(_minArea)
            if(_maxArea>0 and _minArea<0)
                _hasCoss := true
            if(_hasCoss and _maxArea < _tempPice)
                _penInnerError := true
        else if(_pen.direction == -1 and array.size(_pen.area)>0)
            //åˆ¤æ–­æ˜¯å¦å‘ç”Ÿæ­»å‰
            float _maxArea = array.max(_pen.area)
            float _minArea = array.min(_pen.area)
            bool _hasCoss = false
            //å‘ç”Ÿé‡‘å‰çš„è¯åˆ¤æ–­ä¹‹å‰<0çš„æœ€é«˜ç»å¯¹å€¼
            float _tempPice = math.abs(_minArea)
            if(_maxArea>0 and _minArea<0)
                _hasCoss := true
            if(_hasCoss and _tempPice < _maxArea)
                _penInnerError := true
    else if(_gradeNum == 2)
        Grade _gradeOne = array.get(grades,1)
        if(not na(_gradeOne.bCLine) and not na(_gradeOne.innerBCLine))
            _penInnerError := true
    //åˆå§‹èƒŒé©°ä¸ºç©º
    line.delete(_grade.bCLine)
    line.delete(_grade.innerBCLine)
    _grade.bCArea := na
    _grade.innerBCArea :=na
    //åˆ¤æ–­è¿›å‡ºæ®µæ˜¯å¦èƒŒé©°
    if(_segment.endPenIndex != _segment.startPenIndex )//æ’é™¤å•ç¬”æˆæ®µ
        //å–å¾—æœ€åä¸€ä¸ªä¸­æ¢
        Pivot _lastPivot = na
        if(array.size(_segment.pivots)>0)
            _lastPivot := array.last(_segment.pivots)
        bool isComparePivotPen = false
        if(not na(_lastPivot))
            if(array.indexof(_pens,_pen) <= _lastPivot.endPenIndex )
                isComparePivotPen := true
        //print("not na(_lastPivot):"+str.tostring(not na(_lastPivot))+"\npenindex:"+str.tostring(array.indexof(_pens,_pen))+"\nindex:"+str.tostring(_lastPivot.endPenIndex))
        if(isComparePivotPen )
            _comparePen := array.get(_pens,_lastPivot.startPenIndex)
            if(_pen.macdArea<_comparePen.macdArea)
                _segmentError := true
        else if(array.indexof(_pens,_pen)-2>=0)
            _comparePen := array.get(_pens,array.indexof(_pens,_pen)-2)
            //print("------------"+str.tostring(_comparePen.high)+":"+str.tostring(_comparePen.low))
            if(_pen.macdArea<_comparePen.macdArea)
                _segmentError := true
    // if(_gradeNum == 2)
    //     print("\n_penInnerError:"+str.tostring(_penInnerError)+"\n_segmentError:"+str.tostring(_segmentError))
    if(_penInnerError)
        line _line =  line.new(na,na,na,na,xloc = xloc.bar_time,color = pMacdLineColor1,style = line.style_solid,width = pMacdLineWidth)
        line.set_xy1(_line,_pen.startTime,_pen.direction==1?_pen.low:_pen.high)
        line.set_xy2(_line,_pen.endTime,_pen.direction==1?_pen.high:_pen.low)
        if(_segmentError)
            _line.set_color(color = pMacdLineColor3)
        _grade.innerBCLine := _line
        _grade.innerBCArea := _pen.macdArea
    if(_segmentError)
        line _line = line.new(na,na,na,na,xloc = xloc.bar_time,color =pMacdLineColor2,style = line.style_solid,width = pMacdLineWidth)
        line.set_xy1(_line,_comparePen.startTime,_comparePen.direction==1?_comparePen.low:_comparePen.high)
        line.set_xy2(_line,_comparePen.endTime,_comparePen.direction==1?_comparePen.high:_comparePen.low)
        _grade.bCLine := _line
        _grade.bCArea := _comparePen.macdArea
        if(not _penInnerError)
            line _line2 =  line.new(na,na,na,na,xloc = xloc.bar_time,color = pMacdLineColor2,style = line.style_solid,width = pMacdLineWidth)
            line.set_xy1(_line2,_pen.startTime,_pen.direction==1?_pen.low:_pen.high)
            line.set_xy2(_line2,_pen.endTime,_pen.direction==1?_pen.high:_pen.low)
            _grade.innerBCLine := _line2
            _grade.innerBCArea := _pen.macdArea
//å°†æŒ‡å®šçº¿æ®µæ¨¡æ‹Ÿæˆç¬”ï¼Œä»¥ä¾¿åæœŸæ„å»ºæ›´å¤§çº§åˆ«çº¿æ®µ
createSelfPen(int _gradeNum,Segment _segment)=>
    Pen[] _pens= getGradePens(_gradeNum)
    Pen[] _selfPens = getGradeSelfPens(_gradeNum)
    if(not na(_selfPens))
        //è®¡ç®—è¯¥çº¿æ®µåŒ…å«æ‰€æœ‰ç¬”çš„é¢ç§¯
        float _macdArea = 0
        float[] _area = array.new_float()
        for i= _segment.startPenIndex to _segment.endPenIndex+1
            if(i>array.size(_pens)-1)
                break
            Pen _pen = array.get(_pens,i)
            _macdArea += _pen.macdArea
            array.push(_area,_pen.macdArea)
        Pen _virtualPen = na
        if(na(_segment.pen))
            _virtualPen := Pen.new(_segment.high,_segment.low,_segment.startTime,_segment.endTime,1,_segment.direction,macdArea = _macdArea,area = _area)
            _segment.pen := _virtualPen
            array.push(_selfPens,_virtualPen)
        else
            _virtualPen :=_segment.pen
            _virtualPen.high := _segment.high
            _virtualPen.low := _segment.low
            _virtualPen.startTime := _segment.startTime
            _virtualPen.endTime := _segment.endTime
            _virtualPen.macdArea := _macdArea
            _virtualPen.area :=_area
        //print("\n_segment.startPenIndex:"+str.tostring(_segment.startPenIndex)+"\n _segment.endPenIndex:"+str.tostring( _segment.endPenIndex)+"\nsize:"+str.tostring(array.size(_pens))+"\narea:"+str.tostring(_virtualPen.macdArea))
    true
//ç»˜åˆ¶çº¿æ®µ
drawSegment(int _gradeNum,Segment _segment) =>
    clearBeforeDrawPivot(_gradeNum)
    Grade _grade = array.get(grades,_gradeNum)
    Segment[] _segments = getGradeSegments(_gradeNum)
    Pen[] _selfPens = getGradeSelfPens(_gradeNum)
    Pen[] _pens= getGradePens(_gradeNum)
    Segment[] _ableSegments= getGradeAbleSegments(_gradeNum)
    line _line = _segment.line
    if(na(_segment.featureLine))
        _segment.featureLine := array.new<line>()
    //æ²¡æœ‰çº¿å°±å…ˆåˆ›å»º
    if(na(_line))
        int _width =segmentWidth 
        if(_gradeNum==2)
            _width := parentSegmentWidth
        _line := line.new(na,na,na,na,width =_width ,xloc = xloc.bar_time,color = _grade.segmentLineColor,style = _grade.segmentLineNoOverStyle)
        _segment.line  := _line
    line.set_xy1(_line,_segment.startTime,_segment.direction == 1 ? _segment.low : _segment.high)
    line.set_xy2(_line,_segment.endTime,  _segment.direction == 1 ? _segment.high : _segment.low)
    if(array.indexof(_segments,_segment) <= -1)
        //å¦‚æœæœ‰å‰ä¸€ç¬”çš„è¯æ›´æ–°å‰ä¸€ç¬”ä¸ºç¡®å®šçŠ¶æ€
        if(array.size(_segments)>0)
            Segment _preSegment = array.get(_segments,array.size(_segments)-1)
            _preSegment.segmentState := 2
            line.set_style(_preSegment.line,_grade.segmentLineOverStyle)
        _segment.pivots := array.new<Pivot>()
        //å°†çº¿æ®µåŠ å…¥é›†åˆä¸­
        array.push(_segments,_segment)
    if(_segment.segmentState == 2)
        line.set_style(_segment.line,_grade.segmentLineOverStyle)
    if(array.indexof(_segments,_segment) == array.size(_segments) -1)
        _segment.segmentState := 1
        line.set_style(_segment.line,_grade.segmentLineNoOverStyle)
    if(not _grade.isShowLine)
        line.set_xy1(_segment.line,na,na)
        line.set_xy2(_segment.line,na,na)
        //print("insert:"+str.tostring(array.size(segments)))
    //print("\n startPenIndex:"+str.tostring(_segment.startPenIndex)+"\nendPenIndex:"+str.tostring(_segment.endPenIndex))
    if(_segment.segmentState == 2)
        line.set_style(_line,line.style_solid)
    //æ„å»ºæ¨¡æ‹Ÿè¯¥çº¿æ®µå¯¹åº”çš„ç¬”å¯¹è±¡
    createSelfPen(_gradeNum,_segment)
    //å‘å¸ƒæ„å»ºè¶‹åŠ¿æ—¶é—´
    if(_gradeNum == 1)
        array.push(trendEvents,1)
    //ç»˜åˆ¶ä¸­æ¢
    createPivot(_gradeNum,_segment,_pens)
    // //é‡æ–°ç»˜åˆ¶ä¹°å–ç‚¹
    // if( _gradeNum+1 <= array.size(grades)-1)
    //     penOperateHandler(_gradeNum+1)
    //çº¿æ®µèƒŒé©°æ˜¾ç¤ºé€»è¾‘å¤„ç†
    bool isShowMacd = (p_ShowBC_low and _gradeNum==1) ? true : (p_ShowBC and _gradeNum==2) ? true : false
    isShowMacd ? segementMacdHandler(_gradeNum,_segment) : na
//æ£€æµ‹çº¿æ®µæˆç«‹æ¡ä»¶
checkSegmentCondition(int _gradeNum ,Segment _preSegment,Segment _lastSegment,Pen[] _pens)=>
    //å½“å‰éªŒè¯çº¿æ®µæ–¹å‘
    int _direction = -_lastSegment.direction
    int _overNum = 0
    //1:åˆ¤æ–­ä»æœ€åpenå½“å½“å‰æ˜¯å¦è‡³å°‘3æ ¹å¹¶ä¸”æœ€åä¸€æ ¹å’Œæœ€åçº¿æ®µæ–¹å‘ç›¸å
    int _lastEndPenIndex = _lastSegment.endPenIndex
    if( _lastEndPenIndex + 3 < array.size(_pens) )
        _overNum += 1
    // if(_gradeNum == 2)
    //     print("_overNum:"+str.tostring(_overNum)+" \n_lastEndPenIndex:"+str.tostring(_lastEndPenIndex)+"\nsize:"+str.tostring(array.size(_pens)))
    //2:åˆ¤æ–­æœ€åä¸€ç¬”æå€¼æ˜¯å¦è¶…è¿‡ä¸Šä¸Šç¬”
    if(_overNum>=1)
        Pen _lastDirectionPen = na
        //ä»ä¸‹ä¸€ç¬”å¼€å§‹ï¼ŒéªŒè¯æ˜¯å¦æœ‰
        for i=_lastSegment.endPenIndex+1 to array.size(_pens)-1
            Pen _tempPen =  array.get(_pens,i)
            if(_tempPen.direction == _direction)
                if(na(_lastDirectionPen))
                    _lastDirectionPen := _tempPen
                else
                    if(_direction == -1)
                        if(_tempPen.low < _lastDirectionPen.low)
                            _overNum += 1
                            break
                        else
                            _lastDirectionPen := _tempPen
                    if(_direction == 1)
                        if(_tempPen.high > _lastDirectionPen.high)
                            _overNum += 1
                            break
                        else
                            _lastDirectionPen := _tempPen
    bool _isGap = false
    Pen _lastPen = array.get(_pens,array.size(_pens)-1)
    //åˆ¤æ–­æœ€åçº¿æ®µæ˜¯å¦å­˜åœ¨ç¼ºå£
    if(not na(_preSegment))
        if(_lastSegment.endPenIndex - _lastSegment.startPenIndex >= 2  and _preSegment.endPenIndex - _preSegment.startPenIndex >= 2)
            Pen _segmentLastPen = array.get(_pens,_lastSegment.startPenIndex )
            Pen _preSegmentLastPen = array.get(_pens,_preSegment.endPenIndex - 1)
            //åˆ¤æ–­2è€…æ˜¯å¦å­˜åœ¨ç¼ºå£
            if(_lastSegment.direction == 1)
                if( _segmentLastPen.high < _preSegmentLastPen.low)
                    _isGap := true
            else
                if(_segmentLastPen.low > _preSegmentLastPen.high)
                    _isGap := true
    if(_gradeNum == 1)
        debugInfo.debugInfo+="_overNum:"+str.tostring(_overNum)+"\n_isGap:"+str.tostring(_isGap)+"\npensize:"+str.tostring(array.size(_pens))+"\nlast:"+str.tostring(_lastSegment.endPenIndex)
    //3:ç‰¹æ®Šå¤„ç†çº¿æ®µï¼Œå¦‚æœå½“å‰ä¸€ç¬”å¹…åº¦å’Œå‰ä¸€ä¸ªçº¿æ®µç›¸æ¯”è¾¾åˆ°æŒ‡å®šæ•°å€¼å…è®¸ç›´æ¥å¯ä»¥ä¸€ç¬”æˆæ®µ(æ–¹å‘å’Œå½“å‰çº¿æ®µæ–¹å‘ç›¸åæ‰è¡Œ)
    if(_overNum  <2 and not _isGap and array.size(_pens)-1 != _lastSegment.endPenIndex and p_penToSegmentRadio >0)
        if(math.abs(_lastPen.high - _lastPen.low)/math.abs(_lastSegment.high - _lastSegment.low) >= p_penToSegmentRadio/100 
             and _lastPen.direction != _lastSegment.direction)
            _overNum := 2
    _overNum>=2
//è¯¥æ–¹æ³•åˆ¤æ–­çº¿æ®µç ´åæƒ…å†µçŠ¶å†µ
//æ­¤æ–¹æ³•åˆ¤æ–­çº¿æ®µåˆ’åˆ†2ç§æ–¹å¼ ä¸å¤„ç†å·¦åŒ…å«  è¿”å›æ˜¯å¦å½¢æˆå¯¹åº”åˆ†å‹   æ˜¯å¦æœ‰ç¼ºå£
checkSegmentOverType(Segment segment,Pen[] _pens)=>
    //1:è·å¾—è¯¥çº¿æ®µæ–¹å‘
    int _segmentDirection = segment.direction
    //2:è·å¾—æ ‡æ¤ç‰¹å¾åºåˆ—(åªå¤„ç†å³åˆå¹¶)
    Pen[] _resultPen = array.new<Pen>()
    //å‘ç°å¯¹åº”åˆ†å‹index
    int _topOrBottomIndex = -1
    //æ˜¯å¦æœ‰ç¼ºå£
    bool _hasGap = false
    //æŒ‰ç…§é¡ºåºåˆå¹¶ç¬”
    for i=segment.startPenIndex to array.size(_pens) - 1
        Pen _currentPen = array.get(_pens,i)
        //æ–¹å‘ç›¸åŒç›´æ¥ä¸å¤„ç†
        if(_currentPen.direction == _segmentDirection)
            continue
        Pen _lastResultPen = na
        //debugInfo.debugInfo  := "*****\n"
        if(array.size(_resultPen)>0)
            _lastResultPen := array.get(_resultPen,array.size(_resultPen)-1)
        if(na(_lastResultPen))
            array.push(_resultPen,_currentPen)
        else
            //åˆ¤æ–­æ˜¯å¦å­˜åœ¨åŒ…å«å…³ç³»(ä¸å¤„ç†å·¦åŒ…å«)
            isLeftContain  =   (_lastResultPen.high >= _currentPen.high and _lastResultPen.low <= _currentPen.low)
            //isRightContain =   (_currentPen.high >= _lastResultPen.high  and _currentPen.low <= _lastResultPen.low)
            isContain      =   isLeftContain  
            if(isContain)
                Pen _mergePen =na
                if(_segmentDirection == -1)
                    _mergePen := Pen.new(math.min(_currentPen.high , _lastResultPen.high),math.min(_currentPen.low  , _lastResultPen.low))
                else if(_segmentDirection == 1)
                    _mergePen := Pen.new(math.max(_currentPen.high , _lastResultPen.high),math.max(_currentPen.low  , _lastResultPen.low))
                array.pop(_resultPen)
                array.push(_resultPen,_mergePen)
                //debugInfo.debugInfo+="\n"+str.tostring(_mergePen.high)+":"+str.tostring(_mergePen.low)
            else
                array.push(_resultPen,_currentPen)
            if(array.size(_resultPen)>=3)
                //åˆ¤æ–­æ˜¯å¦å‡ºç°å¯¹åº”åˆ†å‹
                Pen _lastPen1 =  array.get(_resultPen,array.size(_resultPen)-1)
                Pen _lastPen2 =  array.get(_resultPen,array.size(_resultPen)-2)
                if(_segmentDirection == -1)
                    //debugInfo.debugInfo+="\n 1top:"+str.tostring(_lastPen2.low)+":"+str.tostring( _lastPen1.low)
                    if(_lastPen2.low < _lastPen1.low)
                        _topOrBottomIndex := array.size(_resultPen)-2
                else if(_segmentDirection == 1)
                    //debugInfo.debugInfo+="\n 2top:"+str.tostring(_lastPen2.high)+":"+str.tostring( _lastPen1.high)
                    if(_lastPen2.high > _lastPen1.high)
                        _topOrBottomIndex := array.size(_resultPen)-2
                if(_topOrBottomIndex!=-1)
                    break
    //debugInfo.debugInfo+="\nsize:"+str.tostring(array.size(_resultPen))+"\n_topOrBottomIndex"+str.tostring(_topOrBottomIndex)
    //print(debugInfo.debugInfo)
    //3:åˆ¤æ–­æ˜¯å¦æ„æˆå¯¹åº”åˆ†å‹åŠæ˜¯å¦å­˜åœ¨ç¼ºå£
    if(_topOrBottomIndex > 0)
        Pen _lastPen1 =  array.get(_resultPen,_topOrBottomIndex-1)
        Pen _lastPen2 =  array.get(_resultPen,_topOrBottomIndex+1)
        if(_segmentDirection == -1)
            if(_lastPen2.high < _lastPen1.low)
                _hasGap :=true
        else if(_segmentDirection == 1)
            if(_lastPen2.low > _lastPen1.high)
                _hasGap :=true
    [_topOrBottomIndex,_hasGap]
//æ ¡éªŒæ˜¯å¦åˆ é™¤å½“å‰çº¿æ®µä¿®å¤ä¸Šä¸€ä¸ªçº¿æ®µ
checkChangeSegment(int _gradeNum,Segment _preSegment,Segment _lastSegment,Pen _lastPen)=>
    bool isChange = false
    Pen[] _pens= getGradePens(_gradeNum)
    //ä¹‹å‰çº¿æ®µæ–¹å‘
    int _preDirection = _preSegment.direction
    //åˆ¤æ–­ä¹‹å‰çº¿æ®µæ˜¯å¦å­˜åœ¨ç¼ºå£
    bool isGap = false
    //æ˜¯å¦è¶…è¿‡ä¹‹å‰çº¿æ®µæå€¼
    bool isMaxNum = false
    Pen _lastSegementFirstPen = array.get(_pens,_lastSegment.startPenIndex)
    Pen _preSegmentLastPen = array.get(_pens,_preSegment.endPenIndex -1)
    //åˆ¤æ–­æ˜¯å¦å‡ºç°æå€¼ç‚¹ï¼Œå¦‚æœåé¢çº¿æ®µè¶…è¿‡å‰é¢çº¿æ®µé«˜ä½ç‚¹
    //ä¹‹å‰çº¿æ®µæ˜¯ä¸Šå‡çº¿æ®µ
    if(_preDirection == 1 )
        if(_lastPen.high > _preSegment.high and _lastSegment.low >= _preSegment.low)
            isMaxNum :=true
    //ä¹‹å‰çº¿æ®µæ˜¯ä¸‹é™çº¿æ®µ
    else
        if(_lastPen.low < _preSegment.low and _lastSegment.high <=_preSegment.high) 
            isMaxNum :=true
    // //å­˜åœ¨ç¼ºå£ï¼Œå¹¶ä¸”å‡ºç°æå€¼
    // if(_gradeNum == 1)
    //     print("_preSegment:"+str.tostring(_preSegment.direction)+" : "+str.tostring(_preSegment.high)+" : "+str.tostring(_preSegment.low)
    //      +"\n _lastSegment:"+str.tostring(_lastSegment.direction)+" : "+str.tostring(_lastSegment.high)+" : "+str.tostring(_lastSegment.low))
    
    if(isMaxNum)
        //åˆ¤æ–­æ˜¯ä¹‹å‰çº¿æ®µå¦æœ‰ç‰¹å¾åºåˆ—åˆ†å‹
        [_topOrBottomIndex,_hasGap] = checkSegmentOverType(_preSegment,_pens)
        // if(_gradeNum == 1)
        //     print("_hasGap:"+str.tostring(_hasGap)+"\n"+str.tostring(_preSegment.direction)+":"+str.tostring(_preSegment.high)+":"+str.tostring(_preSegment.low))
        //æœ‰ç¼ºå£å‡ºç°æå€¼ç›´æ¥è¿›è¡Œä¿®å¤
        if(_hasGap)
            isChange :=true
        else
            //æ²¡æœ‰ç¼ºå£ï¼Œä½†æ˜¯æ ¹æ®çº¿æ®µæ¨¡å¼å¦‚æœä¸æ˜¯ä¸¥æ ¼æ¨¡å¼çš„è¯å¯ä»¥è¿›è¡Œå»¶ä¼¸
            if(p_segmentType!=1)
                isChange :=true
            //å†æ¬¡è¿›è¡Œæ ¡éªŒ,æŒ‰ç…§æ¯”ä¾‹è¿›è¡Œä¿®æ­£
            if(not isChange and p_Segment_Change_Ratio != -1)
                float _checkRadio = math.abs(_lastSegment.high-_lastSegment.low)/math.abs(_preSegment.high-_preSegment.low)
                if(_checkRadio < p_Segment_Change_Ratio/100)
                    isChange :=true   
        // if(_gradeNum == 1)
        //     print("_hasGap:"+str.tostring(_hasGap)+"\nisChange:"+str.tostring(isChange)+"\np_Segment_Change_Ratio:"+str.tostring(p_Segment_Change_Ratio))
    isChange
//æ£€æŸ¥æ„å»ºç¬¬ä¸€ä¸ªçº¿æ®µå¹¶è¿”å›
createFirstSegment(int _gradeNum) =>
    Grade       _grade    = array.get(grades,_gradeNum)
    Pen[]       _pens     = getGradePens(_gradeNum)
    //ç¬”çš„æ•°é‡
    int         _penNum   =array.size(_pens)
    //ç”Ÿæˆçš„çº¿æ®µ
    Segment _segment = na
    int _startPenIndex = 0
    //è‡³å°‘3ç¬”æ„æˆä¸€ä¸ªçº¿æ®µ,éå†å¾ªç¯æ‰¾å‡ºç¬¬ä¸€ä¸ªçº¿æ®µ
    while(_startPenIndex < _penNum)
        //ç¬¬ä¸€ä¸ªåŒå‘ç¬”
        Pen _currentPen = array.get(_pens,_startPenIndex)
        int _nextSameDirectionIndex = _startPenIndex+2
        if(_nextSameDirectionIndex >= _penNum)
            break
        //ä¸‹ä¸€ä¸ªåŒå‘ç¬”
        Pen _nextPen = array.get(_pens, _nextSameDirectionIndex)
        //å¦‚æœåŒå‘ç¬”åä¸€ä¸ªæå€¼è¶…è¿‡å‰ä¸€ä¸ªçš„è¯åˆ¤å®šæˆä¸ºçº¿æ®µ
        if(_currentPen.direction == -1 and _nextPen.low < _currentPen.low and _nextPen.high < _currentPen.high)
            _segment := Segment.new(_currentPen.high,_nextPen.low,_currentPen.startTime,_nextPen.endTime,_startPenIndex,_nextSameDirectionIndex,1,-1)
            drawSegment(_gradeNum,_segment)
            break
        else if(_currentPen.direction == 1 and _nextPen.high > _currentPen.high and _nextPen.low > _currentPen.low)
            _segment := Segment.new(_nextPen.high,_currentPen.low,_currentPen.startTime,_nextPen.endTime,_startPenIndex,_nextSameDirectionIndex,1,1)
            drawSegment(_gradeNum,_segment)
            break
        _startPenIndex += 1
    _segment
//å¯¹æœ€åä¸€æ®µè¿›è¡Œæ‹†åˆ†
segmentSplit(int _gradeNum)=>
    //è·å¾—å½“å‰çº§åˆ«ç›¸å…³ä¿¡æ¯
    Grade _grade = array.get(grades,_gradeNum)
    //å½“å‰çº§åˆ«çº¿æ®µ
    Segment[] _segments = getGradeSegments(_gradeNum)
    //å½“å‰çº§åˆ«æ‰€æœ‰çš„ç¬”ä¿¡æ¯
    Pen[] _pens= getGradePens(_gradeNum)
    //å–å¾—æœ€åä¸€ç¬”
    Pen _lastPen = array.get(_pens,array.size(_pens)-1)
    //å¯èƒ½æˆæ®µçš„æ®µä¿¡æ¯
    Segment[] _ableSegments= getGradeAbleSegments(_gradeNum)
    bool _isChange = false
    Segment _ableSegment = na
    Segment _newSegment = na
    //åˆ¤æ–­å¯èƒ½æˆæ®µåé¢èµ°å‡ºåå‘çº¿æ®µï¼Œ
    if(array.size(_ableSegments)>0 )
        //åˆ¤æ–­ä»å¯èƒ½æˆæ®µæœ€åä¸€ç¬”å¼€å§‹åç»­3ç¬”æ˜¯å¦èƒ½å¤Ÿæ„æˆæ–°çš„çº¿æ®µ
        _ableSegment := array.first(_ableSegments)
        //å¦‚æœçº¿æ®µå¯¹åº”çš„æœ€åä¸€ç¬”å’Œå®é™…ä¸ç›¸åŒä¸åšå¤„ç†(ä¸­é€”ç¬”ä¿®å¤ï¼Œå…¶å®è¯¥çº¿æ®µå·²ç»ä¸å¯ç”¨)
        if(array.size(_pens) <= _ableSegment.endPenIndex)
            array.clear(_ableSegments)
        else
            Pen _lastSegmentPen =  array.get(_pens,_ableSegment.endPenIndex)
            if(_ableSegment.direction == 1 and _lastSegmentPen.high != _ableSegment.high)
                array.clear(_ableSegments)
            else if(_ableSegment.direction == -1 and _lastSegmentPen.low != _ableSegment.low)
                array.clear(_ableSegments)
            else
                Pen _ableFirstPen = na
                if( array.size(_pens)-1 > _ableSegment.endPenIndex)
                    for i = _ableSegment.endPenIndex+1 to array.size(_pens)-1
                        Pen _tempPen = array.get(_pens,i)
                        if(na(_ableFirstPen))
                            _ableFirstPen := _tempPen
                        else
                            if(_ableSegment.direction == -1)
                                if(_tempPen.high > _ableFirstPen.high)
                                    _isChange := true
                                    _newSegment := Segment.new(_tempPen.high,_ableSegment.low,_ableSegment.endTime,_tempPen.endTime,_ableSegment.endPenIndex+1,array.indexof(_pens,_tempPen),1,1)
                                    break
                            else if(_ableSegment.direction == 1)
                                if(_tempPen.low < _ableFirstPen.low)
                                    _isChange := true
                                    _newSegment := Segment.new(_ableSegment.high,_tempPen.low,_ableSegment.endTime,_tempPen.endTime,_ableSegment.endPenIndex+1,array.indexof(_pens,_tempPen),1,-1)
                                    break
    //å–å¾—æœ€åä¸€ä¸ªçº¿æ®µ
    Segment _lastSegment = na
    if(array.size(_segments)>0)
        _lastSegment := array.get(_segments,array.size(_segments)-1)        
    //è¿›è¡Œçº¿æ®µä¿®å¤
    if(_isChange)
        if(_ableSegment.direction == 1)
            //é‡æ–°ç¬¬ä¸€æ®µ
            _lastSegment.low := _ableSegment.low
            _lastSegment.endTime := _ableSegment.startTime
            _lastSegment.endPenIndex := _ableSegment.startPenIndex-1
            drawSegment(_gradeNum,_lastSegment)
            //æ·»åŠ å¯èƒ½æˆç¬”ä¸ºæ­£å¼æˆç¬”
            drawSegment(_gradeNum,_ableSegment)
            //åç»­ä¸€ç¬”
            drawSegment(_gradeNum,_newSegment)
            array.clear(_ableSegments)
        else if(_ableSegment.direction == -1)
            //é‡æ–°æ›´æ–°æœ€åä¸€ç¬”
            _lastSegment.high := _ableSegment.high
            _lastSegment.endTime := _ableSegment.startTime
            _lastSegment.endPenIndex := _ableSegment.startPenIndex-1
            drawSegment(_gradeNum,_lastSegment)
            // //æ·»åŠ å¯èƒ½æˆç¬”ä¸ºæ­£å¼æˆç¬”
            drawSegment(_gradeNum,_ableSegment)
            //åç»­ä¸€ç¬”
            drawSegment(_gradeNum,_newSegment)
            array.clear(_ableSegments)
    true

//@function æ„å»ºçº¿æ®µ
//@param _segments:å¯¹åº”çš„çº¿æ®µé›†åˆ  
//@param _pens:å¯¹åº”çš„ç¬”é›†åˆ  
//@param _selfPens:è‡ªèº«çš„æ¨¡æ‹Ÿç¬”é›†åˆ
//@param _ableSegments:å¯èƒ½æˆæ®µé›†åˆ
createSegment(int _gradeNum) =>
    //è·å¾—å½“å‰çº§åˆ«ç›¸å…³ä¿¡æ¯
    Grade _grade = array.get(grades,_gradeNum)
    //å½“å‰çº§åˆ«çº¿æ®µ
    Segment[] _segments = getGradeSegments(_gradeNum)
    //å½“å‰çº§åˆ«è‡ªèº«çº¿æ®µæ¨¡æ‹Ÿçš„ç¬”ä¿¡æ¯
    Pen[] _selfPens = getGradeSelfPens(_gradeNum)
    //å½“å‰çº§åˆ«æ‰€æœ‰çš„ç¬”ä¿¡æ¯
    Pen[] _pens= getGradePens(_gradeNum)
    //å¯èƒ½æˆç¬”çš„ç¬”ä¿¡æ¯
    _ableSegments= getGradeAbleSegments(_gradeNum)
    //å–å¾—æœ€åä¸€ä¸ªçº¿æ®µ
    Segment _lastSegment = na
    if(array.size(_segments)>0)
        _lastSegment := array.get(_segments,array.size(_segments)-1)
    //ä¸Šä¸ªçº¿æ®µ
    Segment _preSegment = na
    if(array.size(_segments)>=2)
        _preSegment := array.get(_segments,array.size(_segments)-2)
    //å–å¾—æœ€æ–°çš„ç¬”
    Pen _lastPen = array.get(_pens,array.size(_pens)-1)
    //print("_gradeNum:"+str.tostring(_gradeNum)+"\n _grade:"+str.tostring(_grade.gradeNum)+"\n_grade.pens:"+str.tostring(array.size(_grade.pens))+"\npens:"+str.tostring(array.size(pens)))
    int _oldSegmentSize = array.size(_segments)
    //å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªçº¿æ®µçš„è¯
    if(na(_lastSegment)) //æ ¹æ®æ¡ä»¶ç”Ÿæˆç¬¬ä¸€ä¸ªçº¿æ®µ
        Segment _tempSegment =  createFirstSegment(_gradeNum)
    //ä¿®æ­£å·²æœ‰çº¿æ®µæˆ–äº§ç”Ÿæ–°çš„çº¿æ®µ
    if(not na(_lastSegment)) 
        //åˆ¤æ–­æ˜¯å¦äº§ç”Ÿæ–°çš„çº¿æ®µ
        Segment _newSegment = na
        bool    _haveNew    = false
        //éªŒè¯å½“å‰è¿›è¡Œä¸­çš„æ˜¯å¦æˆæ®µ   
        _haveNew := not  _haveNew and checkSegmentCondition(_gradeNum, _preSegment,_lastSegment,_pens) 
        // if(_gradeNum == 2)
        //     print("*******\n_haveNew:"+str.tostring(_haveNew)+"\nstartIndex:"+str.tostring(_lastSegment.endPenIndex)+"\npen:"+str.tostring(array.size(_pens)-1))
        if(_haveNew) //æœ‰æ–°çš„çº¿æ®µ
            int _newDirection =  -_lastSegment.direction
            float _high = _newDirection==1?_lastPen.high:_lastSegment.high
            float _low = _newDirection==1?_lastSegment.low:_lastPen.low
            _newSegment := Segment.new(_high,_low,_lastSegment.endTime,_lastPen.endTime,_lastSegment.endPenIndex+1,array.indexof(_pens,_lastPen),1,_newDirection)
            drawSegment(_gradeNum,_newSegment)
            array.clear(_ableSegments)
        //æ²¡æœ‰ç”Ÿæˆæ–°çš„çº¿æ®µçš„è¯åˆ¤æ–­æ˜¯å¦å¯¹æœ€åçš„çº¿æ®µè¿›è¡Œä¿®æ­£
        if(na(_newSegment))
            if(_lastSegment.direction == _lastPen.direction)
                if( _lastSegment.direction == -1 and _lastPen.low < _lastSegment.low)
                    //æ›´æ–°çº¿æ®µ
                    _lastSegment.low := _lastPen.low
                    _lastSegment.endTime := _lastPen.endTime
                    _lastSegment.endPenIndex := array.size(_pens)-1
                    drawSegment(_gradeNum,_lastSegment)
                if( _lastSegment.direction ==  1 and _lastPen.high > _lastSegment.high)
                    //æ›´æ–°çº¿æ®µ
                    _lastSegment.high := _lastPen.high
                    _lastSegment.endTime := _lastPen.endTime
                    _lastSegment.endPenIndex := array.size(_pens)-1
                    drawSegment(_gradeNum,_lastSegment)
            if(p_segmentType == 3)
                segmentSplit(_gradeNum)
        //æ²¡æœ‰äº§ç”Ÿæ–°çº¿æ®µçš„æ—¶å€™è¿›è¡Œçº¿æ®µä¿®å¤å¤„ç†
        // if(_gradeNum == 1)
        //     print("_newSegment:"+str.tostring(na(_newSegment))+"\n_preSegment:"+str.tostring(not na(_preSegment)))
        if(na(_newSegment) and not na(_preSegment))
            bool _isChange = checkChangeSegment(_gradeNum,_preSegment,_lastSegment,_lastPen)
            // if(_gradeNum == 1)
            //     print("direction:"+str.tostring(_preSegment.direction)+"\n bool1:"+str.tostring(_lastPen.high > _preSegment.high)+"\n bool2:"+str.tostring(_lastSegment.low >= _preSegment.low)+"\n_isChange:"+str.tostring(_isChange))
            if(_preSegment.direction == 1 and _isChange)
                //ä¿®æ­£ä¹‹å‰çº¿æ®µ
                _preSegment.high := _lastPen.high
                _preSegment.endTime := _lastPen.endTime
                _preSegment.endPenIndex := array.indexof(_pens,_lastPen)
                drawSegment(_gradeNum,_preSegment)
                //åˆ é™¤è€çº¿æ®µ
                array.clear(_ableSegments)
                array.push(_ableSegments,_lastSegment)
                delSegment(_gradeNum,_segments,_selfPens,_lastSegment)
            else if(_preSegment.direction == -1 and _isChange )
                //ä¿®æ­£ä¹‹å‰çº¿æ®µ
                _preSegment.low := _lastPen.low
                _preSegment.endTime := _lastPen.endTime
                //_preSegment.pivots := array.new<Pivot>()
                _preSegment.endPenIndex := array.indexof(_pens,_lastPen)
                drawSegment(_gradeNum,_preSegment)
                //åˆ é™¤è€çº¿æ®µ
                array.clear(_ableSegments)
                array.push(_ableSegments,_lastSegment)
                delSegment(_gradeNum,_segments,_selfPens,_lastSegment)
//#endregion

//#region @function æ„å»ºç¬”
drawRunningPen(Pen _lastPen)=>
    if(isShowRunningPen)
        runningPen.startTime := _lastPen.endTime
        runningPen.endTime   := time
        // line _line = line.new(runningPen.startTime,0,runningPen.endTime,0,xloc = xloc.bar_time,style = line.style_dotted,color=penColr,width=1)
        // runningPen.line := _line
        float y1 = 0
        float y2 = _lastPen.direction == 1? low:high
        if(_lastPen.direction == -1)
            if(array.indexof(mergeTime,_lastPen.endTime) > 0 )
                y1 := array.get(mergeLow,array.indexof(mergeTime,_lastPen.endTime))
            if(low < _lastPen.low)
                y2 :=na(line.get_y2(runningPen.line))?low : math.min(line.get_y2(runningPen.line),low)
            else
                y2 :=na(line.get_y2(runningPen.line))?y2 : math.max(line.get_y2(runningPen.line),y2)
        else if(_lastPen.direction == 1)
            if(array.indexof(mergeTime,_lastPen.endTime) > 0 )
                y1 := array.get(mergeHigh,array.indexof(mergeTime,_lastPen.endTime))
            if(high > _lastPen.high)
                y2 :=na(line.get_y2(runningPen.line))?high : math.max(line.get_y2(runningPen.line),high)
            else
                y2 :=na(line.get_y2(runningPen.line))?y2: math.min(line.get_y2(runningPen.line),y2)
        if(y1 != 0)
            line.set_xy1(runningPen.line,runningPen.startTime,y1)
        line.set_xy2(runningPen.line,runningPen.endTime,y2)
        line.delete(runningPen.line)
        line _copyLine = line.copy(runningPen.line)
        runningPen.line:=_copyLine


//åˆ é™¤ç¬”
delPen(Pen _pen) =>
    if(array.indexof(pens,_pen) >= 0)
        line.delete(_pen.line)
        //print(">0:"+str.tostring(array.indexof(pens,_pen) >= 0)+"\npen index:"+str.tostring(array.indexof(pens,_pen)+1)+"\n:"+str.tostring(array.size(pens)))
        //if(array.indexof(pens,_pen) >= 0 and array.indexof(pens,_pen)+1< array.size(pens))
        array.remove(pens,array.indexof(pens,_pen))
        if(array.size(pens)>0)
            Pen _prePen = array.get(pens,array.size(pens)-1)
            _prePen.penState := 1
            line.set_style(_prePen.line,line.style_dashed)
        Segment _lastSegment = na
        if(array.size(segments)>0)
            _lastSegment := array.last(segments)
            if(_lastSegment.endPenIndex >= array.size(pens) )
                delSegment(1,segments,pens,_lastSegment)
        // //ç»˜åˆ¶åˆ›å»ºçº¿æ®µ
        //createSegment(1)
        delDrawPenOperate(1,_pen)
        // //é‡æ–°ç»˜åˆ¶ä¹°å–ç‚¹
        //penOperateHandler(1)


//ç»˜åˆ¶ç¬”å¹¶åšåç»­å¤„ç†
drawPen(Pen _pen) =>
    line _line = _pen.line
    if(na(_line))
        _line := line.new(na,na,na,na,width =penWidth ,xloc = xloc.bar_time,color = penColr,style = line.style_dashed)
        _pen.line  := _line
    if(p_isShowPen)
        line.set_xy1(_line,_pen.startTime,_pen.direction == 1 ? _pen.low : _pen.high)
        line.set_xy2(_line,_pen.endTime,  _pen.direction == 1 ? _pen.high : _pen.low)
    if(array.indexof(pens,_pen) <= -1)
        //å¦‚æœæœ‰å‰ä¸€ç¬”çš„è¯æ›´æ–°å‰ä¸€ç¬”ä¸ºç¡®å®šçŠ¶æ€
        if(array.size(pens)>0)
            Pen _prePen = array.get(pens,array.size(pens)-1)
            _prePen.penState := 2
            line.set_style(_prePen.line,line.style_solid)
        //å°†ç¬”åŠ å…¥é›†åˆä¸­
        array.push(pens,_pen)
    if(_pen.penState == 2)
        line.set_style(_line,line.style_solid)
    //é‡ç½®è¿è¡Œä¸­çš„ç¬”
    if(_pen.direction == -1)
        line.set_xy1(runningPen.line,_pen.endTime,_pen.low)
    else
        line.set_xy1(runningPen.line,_pen.endTime,_pen.high)
    line.set_xy2(runningPen.line,_pen.endTime,na)
    //è®¡ç®—å½“å‰ç¬”å¯¹åº”çš„macdé¢ç§¯
    setPenMacdArea(_pen)
    //print("macdarea:"+str.tostring(_pen.macdArea))
    //ç»˜åˆ¶åˆ›å»ºçº¿æ®µ
    createSegment(1)
    //é‡æ–°ç»˜åˆ¶ä¹°å–ç‚¹
    //penOperateHandler(1)
    //print(str.tostring(_pen.macdArea))

//åˆ¤æ–­æŒ‡å®šç¬”æ˜¯å¦å­˜åœ¨åˆ†å‹
penHasTopAndBottom(Pen _pen) =>
    bool _hasTB  = false
    int _penEndIndex = array.indexof(mergeTime,_pen.endTime)
    if(_penEndIndex != -1)
        if(array.size(mergeTime)-1 > _penEndIndex)
            if(_pen.direction == 1)
                if(array.get(mergeLow,_penEndIndex+1) < array.get(mergeLow,_penEndIndex))
                    _hasTB := true
            else if(_pen.direction == -1)
                if(array.get(mergeHigh,_penEndIndex+1) > array.get(mergeHigh,_penEndIndex))
                    _hasTB := true
    _hasTB
//åˆ¤æ–­æŒ‡å®šç¬”æ˜¯å¦å­˜åå‘åœ¨åˆ†å‹
penHasAfterTopAndBottom(Pen _pen) =>
    int _peakIndex  = -1
    int _penEndIndex = array.indexof(mergeTime,_pen.endTime)
    if(array.size(mergeTime)-1 > _penEndIndex)
        if(_pen.direction == 1)
            //print("&"+str.tostring(array.get(mergeLow,array.size(mergeLow)-1))+":"+str.tostring(array.get(mergeLow,array.size(mergeLow)-2)))
            if(array.get(mergeLow,array.size(mergeLow)-1) > array.get(mergeLow,array.size(mergeLow)-2))
                _peakIndex := array.size(mergeLow)  - 2
        else if(_pen.direction == -1)
            //print("*"+str.tostring(array.get(mergeLow,array.size(mergeLow)-1))+":"+str.tostring(array.get(mergeLow,array.size(mergeLow)-2)))
            if(array.get(mergeLow,array.size(mergeLow)-1) < array.get(mergeLow,array.size(mergeLow)-2))
                _peakIndex :=  array.size(mergeLow) -2
    _peakIndex 
//éªŒè¯åˆå¹¶åçš„æ•°é‡æ˜¯å¦æˆç«‹
checkPenNumHasOver(Pen _pen,int _isTopOrBottom) =>
    bool _penNumHasOver = false
    int _startIndex = array.indexof(mergeTime,_pen.endTime)
    //å®šç‚¹ç´¢å¼•ä½ç½®
    int _endIndex   = array.size(mergeTime) - 2
    if(isFastToPen and _isTopOrBottom == 0 )
        _endIndex   := array.size(mergeTime) - 1
        if(_startIndex+1 < array.size(mergeLow)-1)
            //å¦‚æœå½“å‰ä½ç½®ä¸æ˜¯æœ€é«˜çš„è¯
            if(_pen.direction == 1)
                float[] _temp = array.slice(mergeLow,_startIndex+1,array.size(mergeLow)-1)
                float _price = array.min(_temp)
                //print("2:"+str.tostring(array.get(mergeLow,_endIndex))+"\n_price:"+str.tostring(_price))
                if(array.get(mergeLow,_endIndex) > _price)
                    _endIndex := _startIndex + 1
            else if(_pen.direction == -1)
                float[] _temp = array.slice(mergeHigh,_startIndex+1,array.size(mergeHigh)-1)
                float _price = array.max(_temp)
                //print("1:"+str.tostring(array.get(mergeHigh,_endIndex))+"\n_price:"+str.tostring(_price))
                if(array.get(mergeHigh,_endIndex) < _price)
                    _endIndex := _startIndex + 1
    //è·å¾—å¯¹åº”çš„barIndex
    int _startBarIndex = array.get(mergeBarIndex,_startIndex)
    int _endBarIndex = array.get(mergeBarIndex,_endIndex)
    //if(array.indexof(ablePen,_pen) != -1 ) 
    //print("************_endIndex:"+str.tostring(_endIndex)+"\n_startIndex:"+str.tostring(_startIndex)+"\nisFastToPen:"+str.tostring(isFastToPen)+"\n_isTopOrBottom:"+str.tostring(_isTopOrBottom))
    if(penType == -4)
        //æ–°ç¬”(ä¹‹é—´æœ€å°‘5æ ¹Kçº¿ï¼Œ4æ ¹ä¸åŒ…å«å…³ç³»çš„kçº¿)
        //print("_startBarIndex:"+str.tostring(_startIndex)+"\n_endBarIndex:"+str.tostring(_endIndex))
        if( math.abs(_endIndex -_startIndex ) + 1>=4 and  math.abs(_startBarIndex - _endBarIndex )+ 1 >= 5)
            _penNumHasOver := true 
    else
        if(math.abs(_endIndex - _startIndex)+1 >= math.abs(penType))
            _penNumHasOver := true
    //å¦‚æœæ˜¯ä¸¥æ ¼ç¬”çš„è¯è¿›è¡Œå†æ¬¡åˆ¤æ–­ç‹¬ç«‹kçº¿æ˜¯å¦é‡åˆ
    if(_penNumHasOver and penTypeStr == "ä¸¥ç¬”")
        if(_pen.direction == -1 )
            float[] _temp = array.slice(mergeHigh,_startIndex+2,_endIndex)
            //print("---"+str.tostring(_temp))
            float _lastPrice  = array.get(mergeHigh,_startIndex+1)
            float _maxPrice  = array.get(mergeHigh,_endIndex)
            //print("2array.max(_temp):"+str.tostring(array.max(_temp))+"\n_lastPrice:"+str.tostring(_lastPrice))
            if(array.max(_temp) <= _lastPrice )
                _penNumHasOver := false
        else if(_pen.direction == 1)
            float[] _temp = array.slice(mergeLow,_startIndex+2,_endIndex)
            //print("---"+str.tostring(_temp))
            float _lastPrice  = array.get(mergeLow,_startIndex+1)  
            //print("1array.min(_temp):"+str.tostring(array.min(_temp))+"\n_lastPrice:"+str.tostring(_lastPrice))
            if(array.min(_temp) >= _lastPrice)
                _penNumHasOver := false
    //print("_endIndex:"+str.tostring(_endIndex)+"\n_startIndex:"+str.tostring(_startIndex)+"\npenType:"+str.tostring(penType)+"\n_penNumHasOver:"+str.tostring(_penNumHasOver))
    //å¦‚æœæ˜¯ä¸¥æ ¼ç¬”çš„è¯è¿›è¡Œå†æ¬¡åˆ¤æ–­ç‹¬ç«‹kçº¿æ˜¯å¦é‡åˆ
    if(_penNumHasOver and penTypeStr == "ä¸¥ç¬”")
        if(_pen.direction == -1 )
            float[] _temp = array.slice(mergeHigh,_startIndex+2,_endIndex-1)
            float _lastPrice  = array.get(mergeHigh,_startIndex+1)
            if(array.max(_temp) <= _lastPrice )
                _penNumHasOver := false
        else if(_pen.direction == 1)
            float[] _temp = array.slice(mergeLow,_startIndex+2,_endIndex-1)
            float _lastPrice  = array.get(mergeLow,_startIndex+1)  
            if(array.min(_temp) >= _lastPrice)
                _penNumHasOver := false
    //ç‰¹æ®Šæƒ…å†µ(é¡¶åº•æ¯”ä¾‹è¾¾åˆ°æŒ‡å®šå€¼å°±å¯ä»¥æˆç¬”,ä¸ç”¨é™åˆ¶kçº¿çš„æ•°é‡)     
    //print("_penNumHasOver:"+str.tostring(_penNumHasOver)+"\np_TopAndBottom_Ratio:"+str.tostring(p_TopAndBottom_Ratio))  
    if(not _penNumHasOver and p_TopAndBottom_Ratio > 0 )
        float _num = 0
        if(_pen.direction == 1)
            _num := (_pen.high - array.get(mergeLow,_endIndex) )/(_pen.high - _pen.low)
        if(_pen.direction == -1)
            _num := (array.get(mergeHigh,_endIndex)  -_pen.low )/(_pen.high - _pen.low)
        if(_num >= p_TopAndBottom_Ratio/100)
            _penNumHasOver := true
    _penNumHasOver

//æœ¬æ–¹æ³•é’ˆå¯¹ç¬¬ä¸€ç¬”ç‰¹æ®Šå¤„ç†
createFistPen(_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice) =>
    //æ³¨é‡Šå¤ªå¤šæ²¡å¿…è¦çš„ï¼Œä¸ºäº†å˜é‡é™åˆ¶
    Pen _pen = na
    //å–å¾—å½“å‰é›†åˆä¸­æœ€ä½ç‚¹åŠä½ç½®
    float _minLowPrice = array.min(mergeLow)
    int bottomIndex = array.indexof(mergeLow,_minLowPrice) 
    // int minBottomTime = array.get(mergeTime,bottomIndex)  
    // int _minBarIndex = array.get(mergeBarIndex,bottomIndex)
    //å–å¾—å½“å‰é›†åˆä¸­æœ€é«˜ç‚¹åŠä½ç½®
    float _maxHighPrice = array.max(mergeHigh)
    int topIndex = array.indexof(mergeHigh,_maxHighPrice)
    // int maxTopTime = array.get(mergeTime,topIndex)  
    // int _maxBarIndex = array.get(mergeBarIndex,topIndex)


    bool isEnough =true
    //é¡¶åº•åˆ†å‹åˆå¹¶åkçº¿æ•°é‡
    int mergeKbarNum = math.abs(topIndex - bottomIndex) + 1 
    if(mergeKbarNum < penType)
        isEnough := false
    // //æ–°ç¬”çš„è¯åˆ¤æ–­ä¸­é—´kçº¿æ•°é‡æ˜¯å¦è¶³å¤Ÿ
    if(penType == -4 and bar_index<5)
        isEnough := false
    //print("topIndex:"+str.tostring(topIndex)+"\nbottomIndex:"+str.tostring(bottomIndex)+"\nbar_index:"+str.tostring(bar_index)+"\nisEnough:"+str.tostring(isEnough))
    //æœ€é«˜é¡¶åº•ä¹‹é—´kçº¿æ•°é‡>æŒ‡å®šæ•°é‡å°±å¯ä»¥æˆç¬”äº†
    if(isEnough)
        _pen := Pen.new(_maxHighPrice,_minLowPrice
                                     ,(array.get(mergeTime,topIndex) > array.get(mergeTime,bottomIndex))?array.get(mergeTime,bottomIndex):array.get(mergeTime,topIndex)
                                     ,(array.get(mergeTime,topIndex) > array.get(mergeTime,bottomIndex))?array.get(mergeTime,topIndex):array.get(mergeTime,bottomIndex)
                                     ,1
                                     ,(array.get(mergeTime,topIndex) > array.get(mergeTime,bottomIndex))?1:-1)
    if(not na(_pen))
        drawPen(_pen)

    _pen

//å¦‚æœå½“å‰ç¬”éœ€è¦ä¿®æ­£çš„è¯è¿›è¡Œä¿®æ­£
penChange(Pen _pen,int _isTopOrBottom,int _topOrBottomTime,float _topOrBottomPrice)=>
    //è·å¾—å½“å‰ç¬”æ–¹å‘
    int _direction = _pen.direction
    int _endIndex   = array.size(mergeTime) - 1
    //åˆ¤æ–­æ˜¯å¦æˆç«‹æœ¬ç¬”çš„ä¿®æ­£é¡¶åº•åˆ†å‹
    bool _hasSelfTB = false
    if(_direction == 1 and _isTopOrBottom == 1)
        //é¡¶åˆ†å‹
        _hasSelfTB := true
    if(_direction == -1 and _isTopOrBottom == -1)
        //åº•åˆ†å‹
        _hasSelfTB  := true
    float _newPrice = float(na)
    int   _newTime  = int(na)
    //å¦‚æœå¿«é€Ÿæˆç¬”æ¨¡å¼çš„è¯ï¼Œè·å¾—æœ€åä¸€æ¬¡åˆå¹¶kä»·å€¼
    if(isFastToPen  ) //and not _hasSelfTB
        _newPrice := _direction == 1 ? array.last(mergeHigh) : array.last(mergeLow)
        _newTime  := array.last(mergeTime) 
    if(_hasSelfTB)
        _newPrice := _topOrBottomPrice
        _newTime  := _topOrBottomTime

    bool _isChange = false
    if(not na(_newPrice) and not na(_newTime))
        //ä¿®æ­£æœ¬ç¬”
        if(_direction == 1 and _newPrice >= _pen.high)
            _pen.high    := _newPrice
            _pen.endTime := _newTime
            if(array.indexof(ablePen,_pen)<0)
                drawPen(_pen)
                _isChange := true
        else if(_direction == -1 and _newPrice <= _pen.low)
            _pen.low    := _newPrice
            _pen.endTime := _newTime
            if(array.indexof(ablePen,_pen)<0)
                drawPen(_pen)
                _isChange := true
    if(_isChange)
        delDrawPenOperate(1,_pen)

//åˆ¤æ–­æ˜¯å¦ç”Ÿæˆä¸‹ä¸€ç¬”
//@return ç”Ÿæˆçš„æ–°ç¬”
penGenerateNextPen(Pen _pen,int _isTopOrBottom)=>
    Pen _nextPen = na
    //è·å¾—å½“å‰ç¬”æ–¹å‘
    int _direction = _pen.direction
    //åˆ¤æ–­ä¸‹ä¸€ç¬”æ•°é‡æ˜¯å¦è¶³å¤Ÿ
    int _startIndex = array.indexof(mergeTime,_pen.endTime)
    int _endIndex   = array.size(mergeTime) - 2
    if(_startIndex!=-1 and _endIndex!= -1)
        //åˆ¤æ–­ä¸‹ä¸€ç¬”æ˜¯å¦å‡ºç°åˆ†å‹
        bool _hasNextTB = _isTopOrBottom == -_direction
        //åˆ¤æ–­ä¸‹ä¸€ç¬”æ•°é‡æ˜¯å¦æ»¡è¶³
        bool _penNumHasOver = false
        //æ»¡è¶³çš„è¯åˆ¤æ–­æ˜¯å¦å½¢æˆå¯¹åº”åˆ†å‹
        if(_hasNextTB or isFastToPen) //(isFastToPen and _isTopOrBottom == 0)
            _penNumHasOver := checkPenNumHasOver(_pen,_isTopOrBottom)
        //if(array.indexof(ablePen,_pen) != -1 )
        //print("_hasNextTB:"+str.tostring(_hasNextTB)+"\nisFastToPen:"+str.tostring(isFastToPen)+"\n_isTopOrBottom:"+str.tostring(_isTopOrBottom))
        //éªŒè¯é¡¶åº•åˆ†å‹æ˜¯å¦ç¬¦åˆæ¡ä»¶
        bool _checkCondition2 =false
        if(_penNumHasOver)
            if(isFastToPen and (_isTopOrBottom == 0  or _isTopOrBottom==_direction ))
                _endIndex := array.size(mergeTime) - 1
            if(oldPenMode) //è€ç‰ˆæœ¬ç¬”ä¸è€ƒè™‘é¡¶åº• äº¤é›†å…³ç³»ï¼Œåªéœ€è¦é¡¶>åº•  
                if(_direction == 1)
                    //åº•åˆ†å‹
                    _checkCondition2 := _pen.high > array.get(mergeHigh,_endIndex) 
                    //print("********************1:"+str.tostring(_pen.high)+"\n :"+str.tostring(array.get(mergeHigh,_endIndex) ))
                if(_direction == -1)
                    //print("******")
                    //é¡¶åˆ†å‹
                    _checkCondition2 := array.get(mergeHigh,_endIndex)  > array.get(mergeHigh,array.indexof(mergeTime,_pen.endTime))
                    //print("********************2:"+str.tostring(array.get(mergeHigh,_endIndex))+"\n :"+str.tostring( array.get(mergeHigh,array.indexof(mergeTime,_pen.endTime)))+"\nhigh:"+str.tostring(_pen.high)+"\nlow:"+str.tostring(_pen.low))
            else
                // //å¤„ç†å·¦åŒ…å«çš„é¡¶åº•åŒºåŸŸ
                // if(_direction == 1)
                //     float[] _temp = array.slice(mergeLow,_startIndex - 1, _startIndex + 2)
                //     float _fxMinPrice = array.min(_temp)
                //     //åº•åˆ†å‹
                //     _checkCondition2 := _fxMinPrice  >  array.get(mergeLow,_endIndex)
                //     //print("1_fxMinPrice:"+str.tostring(_fxMinPrice)+"\n array.get(mergeLow,_endIndex):"+str.tostring( array.get(mergeLow,_endIndex))+"\n "+str.tostring(_pen.high)+":"+str.tostring(_pen.low))
                // if(_direction == -1)
                //     float[] _temp = array.slice(mergeHigh,_startIndex - 1, _startIndex + 2)
                //     float _fxMinPrice = array.max(_temp)
                //     //print("2_fxMinPrice:"+str.tostring(_fxMinPrice)+"\n array.get(mergeHigh,_endIndex)  :"+str.tostring( array.get(mergeHigh,_endIndex))+"\n "+str.tostring(_pen.high)+":"+str.tostring(_pen.low))
                //     //é¡¶åˆ†å‹
                //     _checkCondition2 := _fxMinPrice < array.get(mergeHigh,_endIndex)
                if(_direction == 1)
                    //åº•åˆ†å‹
                    _checkCondition2 := array.get(mergeLow,array.indexof(mergeTime,_pen.endTime))  > array.get(mergeHigh,_endIndex) 
                if(_direction == -1)
                    //é¡¶åˆ†å‹
                    _checkCondition2 := array.get(mergeLow,_endIndex)  > array.get(mergeHigh,array.indexof(mergeTime,_pen.endTime))
        // if(array.indexof(ablePen,_pen) != -1 ) 
        //print("_penNumHasOver:"+str.tostring(_penNumHasOver)+"\n_checkCondition2:"+str.tostring(_checkCondition2)+"\n_direction:"+str.tostring(_direction))
        //æ»¡è¶³æ¡ä»¶ç”Ÿæˆæ–°ç¬”
        if(_checkCondition2)
            float _nextHigh = _direction == 1?_pen.high:array.get(mergeHigh,_endIndex) 
            float _nextLow = _direction == 1?array.get(mergeLow,_endIndex ): _pen.low
            int   _nextEndTime = array.get(mergeTime,_endIndex )
            //if(array.indexof(ablePen,_pen) != -1 ) 
                //print("-------------------------------------------------------_nextHigh:"+str.tostring(_nextHigh)+":"+str.tostring(_nextLow)+":"+str.tostring(array.get(mergeHigh,_endIndex))+":"+str.tostring(array.get(mergeHigh,array.size(mergeHigh)-1)))
            _nextPen := Pen.new( _nextHigh,_nextLow, _pen.endTime,_nextEndTime,1, -_direction)
            //è¯¥ç¬”ä¸æ˜¯å¯èƒ½æˆç¬”çš„è¯æ‰ç«‹åˆ»è¿›è¡Œåˆ’çº¿
            if(array.indexof(ablePen,_pen) == -1 )
                drawPen(_nextPen)
                array.clear(ablePen)
    _nextPen
//å¯¹æœ€åä¸€ç¬”è¿›è¡Œæ‹†åˆ†
penSplit(Pen _ablePen,Pen _nextPen)=>
    //å–å¾—æœ€åä¸€ç¬”
    Pen _lastPen = array.get(pens,array.size(pens) - 1)
    float _topOrBottomPrice =_nextPen.direction ==1 ? _nextPen.high:_nextPen.low
    int _topOrBottomTime = _nextPen.endTime
    bool _isChange = true
    //debugInfo.debugInfo := ""
    if(_ablePen.direction == 1 )
        if(_topOrBottomPrice > _lastPen.low)
            _isChange := false
            //array.remove(ablePen,array.indexof(ablePen,_ablePen))
        if(_isChange)
            //é‡æ–°æ›´æ–°æœ€åä¸€ç¬”
            _lastPen.endTime := _ablePen.startTime
            _lastPen.low := _ablePen.low
            drawPen(_lastPen)
            //æ·»åŠ å¯èƒ½æˆç¬”ä¸ºæ­£å¼æˆç¬”
            drawPen(_ablePen)
            //åç»­ä¸€ç¬”
            drawPen(_nextPen)
            array.remove(ablePen,array.indexof(ablePen,_ablePen))
    else if(_ablePen.direction == -1 )
        //print("++++++++++++++++++++++++++++++++++++++++++++"+str.tostring(_topOrBottomPrice)+":"+str.tostring(_lastPen.high))
        if(_topOrBottomPrice < _lastPen.high)
            _isChange := false
            //array.remove(ablePen,array.indexof(ablePen,_ablePen))
        if(_isChange)
            //é‡æ–°æ›´æ–°æœ€åä¸€ç¬”
            _lastPen.endTime := _ablePen.startTime
            _lastPen.high := _ablePen.high
            drawPen(_lastPen)
            // //æ·»åŠ å¯èƒ½æˆç¬”ä¸ºæ­£å¼æˆç¬”
            drawPen(_ablePen)
            //åç»­ä¸€ç¬”
            drawPen(_nextPen)
            array.remove(ablePen,array.indexof(ablePen,_ablePen))
    //print(debugInfo.debugInfo)

//ç¬”å†…éƒ¨çš„å¤„ç†é€»è¾‘
penInnerHandler(Pen _pen,_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice)=>
    //è·å¾—å½“å‰ç¬”æ–¹å‘
    int _direction = _pen.direction
    Pen _nextPen = na
    //åˆ¤æ–­æ˜¯å¦äº§ç”Ÿä¸‹ä¸€ç¬”
    _nextPen := penGenerateNextPen(_pen,_isTopOrBottom)
    if(na(_nextPen))
        //åˆ¤æ–­æ˜¯å¦æˆç«‹æœ¬ç¬”çš„ä¿®æ­£é¡¶åº•åˆ†å‹
        penChange(_pen,_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice)
    //debugInfo.debugInfo +="\n"+str.tostring(array.indexof(ablePen,_pen))+":"+str.tostring(_pen.high)+":"+str.tostring(_pen.low)
    //å¦‚æœå½“å‰ç¬”æ˜¯å¯èƒ½æˆç¬”ä¸­çš„è¯ï¼Œå¹¶ä¸”äº§ç”Ÿæ–°ç¬”ï¼Œè¿›è¡Œç¬”æ‹†åˆ†
    if(array.indexof(ablePen,_pen)>=0 and not na(_nextPen))
        //print("--------------------------------------------------")
        penSplit(_pen,_nextPen)
    _nextPen
//åˆ¤æ–­è¯¥ç¬”æ˜¯å¦å·¦åŒ…å«
penLeftContain(Pen _pen) =>
    bool isLeftContain = false
    if(array.indexof(mergeTime,_pen.startTime)>=1)
        int leftBarIndex =array.get(mergeBarIndex , array.indexof(mergeTime,_pen.startTime)-1)
        int rightBarIndex =array.get(mergeBarIndex , array.indexof(mergeTime,_pen.startTime)+1)
        //print("direction:"+str.tostring(_pen.direction)+"\nhigh:"+str.tostring(_pen.high)+":"+str.tostring(_pen.low))
        // if(leftBarIndex > bar_index)
        //     runtime.error("leftBarIndex"+str.tostring(leftBarIndex))
        if(bar_index-leftBarIndex < 1000)
            if(_pen.direction == 1 and _pen.high < math.max(high[bar_index-leftBarIndex],high[bar_index-rightBarIndex]))
                //print(str.tostring(high[bar_index-leftBarIndex])+":"+str.tostring(high[bar_index-rightBarIndex])+":"+str.tostring(_pen.high))
                isLeftContain := true
            if(_pen.direction == -1 and _pen.low > math.min(low[bar_index-leftBarIndex],high[bar_index-rightBarIndex]))
                isLeftContain := true
    if(oldPenMode)
        isLeftContain := false
    isLeftContain
//å¤„ç†æ•´ä¸ªæˆç¬”é€»è¾‘
penHandler(_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice)=>
    //å¦‚æœå½“å‰æ²¡æœ‰ç¬”çš„è¯ç”Ÿæˆç¬¬ä¸€ä¸ªç¬”
    if(array.size(pens) <= 0)
        Pen _firstPen = createFistPen(_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice)
    else
        //å–å¾—æœ€åçš„ç¬”
        Pen _lastPen =  array.get(pens,array.size(pens)-1)
        //ä¸Šä¸€ä¸ªåŒæ–¹å‘ç¬”
        Pen _prePen = na
        if(array.size(pens) >= 2)
            _prePen := array.get(pens,array.size(pens)-2)
        //ç”Ÿæˆçš„æ–°ç¬”//å¦‚æœå­˜å¯èƒ½æˆç¬”å…ˆå¤„ç†å¯èƒ½æˆç¬”çš„é«˜ä½ç‚¹
        Pen _nextPen = (array.size(ablePen)>0 ) ? penInnerHandler(array.get(ablePen,0),_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice) : na
        //å¤„ç†å½“å‰è¿›è¡Œä¸­çš„ç¬”
        if(na(_nextPen))
            _nextPen := penInnerHandler(_lastPen,_isTopOrBottom,_topOrBottomTime,_topOrBottomPrice)
        //ä¿®æ­£ç¬”(å‰ä¸¤ç¬”)
        if(na(_nextPen) and not na(_prePen) and _isTopOrBottom != 0)
            //print("_lastPen.low:"+str.tostring(_lastPen.low)+"\n_prePen.low:"+str.tostring(_prePen.low))
            //æœ€åç¬”å’Œå‰ä¸€ç¬”æ¯”ä¾‹è¾¾åˆ°61.8çš„è¯ä¸è¿›è¡Œä¿®å¤
            //bool reboundRadio = (_lastPen.high - _lastPen.low)/(_prePen.high-_prePen.low)*100 < 61.8
            if(_prePen.direction == 1  and _lastPen.low> _prePen.low and _isTopOrBottom == 1 and _topOrBottomPrice > _prePen.high )
                //å°†åˆ é™¤çš„ç¬”æ”¾å…¥å¯èƒ½æˆç¬”ä¸­
                array.clear(ablePen)
                if(not penLeftContain(_lastPen))
                    array.push(ablePen,_lastPen)
                _prePen.high := _topOrBottomPrice
                _prePen.endTime :=  _topOrBottomTime
                delPen(_lastPen)
                drawPen(_prePen)
            else if(_prePen.direction == -1  and _lastPen.high < _prePen.high  and _isTopOrBottom == -1 and _topOrBottomPrice < _prePen.low)
                //å°†åˆ é™¤çš„ç¬”æ”¾å…¥å¯èƒ½æˆç¬”ä¸­
                array.clear(ablePen)
                if(not penLeftContain(_lastPen))
                    array.push(ablePen,_lastPen)
                _prePen.low := _topOrBottomPrice
                _prePen.endTime :=  _topOrBottomTime
                delPen(_lastPen)
                drawPen(_prePen) 
    if(array.size(pens)>0)
        drawRunningPen(array.get(pens,array.size(pens)-1))

//ç»˜åˆ¶å¼ºåŠ¿åˆ†å‹
drawPowerfulPeek(Pen _pen,PeekEvent _peekEvent)=>
    // float[]  peakTypes= array.new<float>(na)
    // array.push(peakTypes,0)
    // array.push(peakTypes,0)
    // array.push(peakTypes,0)
    // if(not na(_pen) and not na(_peekEvent))
    //     if(_pen.direction == _peekEvent.isTopOrBottom)
    //         //1:å¦‚æœæœ‰èƒŒé©°çš„æ”¯æŒæœ€é«˜æƒé™(è¯¥ç¬”å¯¹åº”çš„çº¿æ®µçš„èƒŒé©°)
    //         if(array.size(segments) > 0)
    //             Segment _lastSegment = array.last(segments)
    //             if(array.indexof(pens,_pen) == _lastSegment.endPenIndex )
    //                 //å–å¾—è¯¥ç¬”ä¹‹å‰çš„æå€¼
    //                 float _peekMacdValue = 0
    //                 for i = _lastSegment.startPenIndex to _lastSegment.endPenIndex
    //                     if(i == array.indexof(pens,_pen))
    //                         continue
    //                     Pen _tempPen = array.get(pens,i)
    //                     if(_lastSegment.direction == 1 and array.max(_tempPen.area) >0)
    //                         _peekMacdValue:=_peekMacdValue==0?array.max(_tempPen.area):array.max(_tempPen.area)>_peekMacdValue?array.max(_tempPen.area):_peekMacdValue
    //                     else if(_lastSegment.direction == -1 and  array.min(_tempPen.area) <0)
    //                         _peekMacdValue:=_peekMacdValue==0?array.min(_tempPen.area):array.min(_tempPen.area)<_peekMacdValue?array.min(_tempPen.area):_peekMacdValue   
    //                 //åˆ¤æ–­æ˜¯å¦èƒŒé©°
    //                 int      _penBarIndex = array.get(mergeBarIndex,array.indexof(mergeTime,_pen.endTime))
    //                 float    _penMacd     = array.get(macdHist,_penBarIndex)
    //                 if(_lastSegment.direction == 1 and _penMacd <= _peekMacdValue)
    //                     array.set(peakTypes,0,1)
    //                 else if(_lastSegment.direction == -1 and _penMacd >= _peekMacdValue)
    //                     array.set(peakTypes,0,1)
    //         //å–å¾—ä¸‰æ ¹kçº¿ä¿¡æ¯
    //         int   _barIndex = array.indexof(mergeBarIndex,_peekEvent.peekBarIndex)
    //         float _open1  = open[(bar_index -array.get(mergeBarIndex,_barIndex -1))]
    //         float _close1 = close[(bar_index - array.get(mergeBarIndex,_barIndex - 1))]
    //         float _high1  = high[(bar_index - array.get(mergeBarIndex,_barIndex - 1))]
    //         float _low1   = low[(bar_index - array.get(mergeBarIndex,_barIndex -1))]

    //         float _open2  = open[(bar_index - _peekEvent.peekBarIndex)]
    //         float _close2 = close[(bar_index - _peekEvent.peekBarIndex)]
    //         float _high2  = high[(bar_index - _peekEvent.peekBarIndex)]
    //         float _low2   = low[(bar_index - _peekEvent.peekBarIndex)]

    //         float _open3  = open[(bar_index     - array.get(mergeBarIndex,_barIndex+1) )]
    //         float _close3 = close[(bar_index    - array.get(mergeBarIndex,_barIndex+1)  )]
    //         float _high3  = high[(bar_index     - array.get(mergeBarIndex,_barIndex+1) )]
    //         float _low3   = low[(bar_index      - array.get(mergeBarIndex,_barIndex+1) )]
    //         //2:å¦‚æœç¬¬äºŒæ ¹æ˜¯é•¿ä¸Šå½±(50% )æˆ–è€…ç›´æ¥é•¿é˜´(70) ç¬¬ä¸‰æ ¹ä¸èƒ½ä»¥é˜³çº¿æ”¶åœ¨ç¬¬äºŒæ ¹ä¸€åŠä»¥ä¸Š
    //         float _hatch  =  ((_open2 > _close2) ? _high2 - _open2 : _high2 - _low2)/math.abs(_high2 - _low2)
    //         float _lengBar = math.abs(_open2 - _low2)/ math.abs(_high2 - _low2)
    //         _lengBar := (_pen.direction == 1 and _open2 > _close2)?0:(_pen.direction == -1 and _open2 < _close2)?0:_lengBar
    //         if(_hatch>0.5 or  _lengBar > 0.7)
    //             if(_close3 < (_high2 - _low2)/2 + _low2)
    //                 array.set(peakTypes,1,1)
    //         //3:ç¬¬ä¸‰æ ¹Kçº¿è·Œç ´ç¬¬ä¸€æ ¹kçº¿ä½ç‚¹,å¹¶ä¸”ä¸èƒ½æ”¶ç›˜åœ¨ç¬¬ä¸€æ ¹åŒºé—´1åŠä»¥ä¸Š(è¾ƒå¼ºæ€ä¼¤åŠ›)
    //         if(_low3 <= _low1 and _close3 < (_high1 - _low1)/2 + _low1 )
    //             array.set(peakTypes,2,1)
    //         //4:æ’é™¤æ¡ä»¶1: å‡ºç°kçº¿æ•°é‡è¶…è¿‡5æ ¹
    //         if(array.get(peakTypes,0)<=0 and array.sum(peakTypes) > 0 and array.get(mergeBarIndex,_barIndex+1) -array.get(mergeBarIndex,_barIndex-1)>=4 )
    //             array.set(peakTypes,0,0),array.set(peakTypes,1,0),array.set(peakTypes,2,0)
    //         //5:æ’é™¤æ¡ä»¶2: è¯¥ç¬”å†…éƒ¨æ²¡æœ‰ç»“æ„
    //         if(array.get(peakTypes,0)<=0 and array.sum(peakTypes) > 0)
    //             int _penStartIndex = array.indexof(mergeTime,_pen.startTime)
    //             int _penEndIndex = array.indexof(mergeTime,_pen.endTime)
    //             _peeks = array.slice(peakIndexs,array.indexof(mergeTime,_pen.startTime),array.indexof(mergeTime,_pen.endTime))
    //             if(array.range(_peeks)<2)
    //                 array.set(peakTypes,0,0),array.set(peakTypes,1,0),array.set(peakTypes,2,0)
    //         //å¦‚æœå­˜åœ¨å¼ºåŠ¿åˆ†å‹çš„è¯è¿›è¡Œç»˜åˆ¶
    //         if(array.sum(peakTypes) > 0 )
    //             float _maxHigh = math.max(_high1,_high2,_high3)
    //             float _maxLow  = math.min(_low1,_low2,_low3)
    //             //print("_maxHigh:"+str.tostring(_maxHigh)+"\n_maxLow:"+str.tostring(_maxLow)+"\n"+str.tostring(_high1)+":"+str.tostring(_low1)+"\n"+str.tostring(_high2)+":"+str.tostring(_low2)+"\n"+str.tostring(_high3)+":"+str.tostring(_low3))
    //             int _showLast = bar_index -array.indexof(mergeBarIndex,_peekEvent.peekBarIndex) - 1
    //             string tooltip = str.tostring(array.get(peakTypes,0))+"-"+str.tostring(array.get(peakTypes,1))+"-"+str.tostring(array.get(peakTypes,2))
    //             box.new(array.get(mergeBarIndex,_barIndex-1),_maxHigh,array.get(mergeBarIndex,_barIndex+1),_maxLow
    //                      ,border_color=_pen.direction==1?color.red:color.green,bgcolor=color.rgb(255, 255, 255, 100),text=tooltip)
    true

//#endregion        
//åˆ¤æ–­æ˜¯å¦éœ€è¦å¤„ç†ï¼Œå¦‚æœè®¾ç½®äº†kçº¿åˆ†ææ•°é‡
bool isCyc = true
if(p_max_cyc_bar!=0 and bar_index < last_bar_index - p_max_cyc_bar)
    isCyc := false
Pen _realLastPen = na
//ä¿å­˜æ¯ä¸€ä¸ªkçº¿çš„macdé¢ç§¯
array.push(macdHist,histLine)
//åˆå§‹åŒ–æŠ¥è­¦ç›¸å…³è®¾ç½®
initAlertFlag()
//ç³»ç»Ÿå¯åŠ¨æ˜¯é¦–æ¬¡åˆå§‹åŒ–çº§åˆ«ä¿¡æ¯
initGrade()
//åˆå¹¶é¡¶åº•åˆ†å‹
[isTopOrBottom,topOrBottomTime,topOrBottomPrice] = mergeBarAndFindTopAndBottom(isCyc)
// //å±•ç¤ºå¤„ç†åˆå¹¶Kçº¿
float _mergeOpen = na
if(isShowMergeBar and array.size(mergeHigh)>0)
    _mergeOpen := array.last(mergeHigh)
plotcandle(_mergeOpen,array.size(mergeHigh)>0?array.last(mergeHigh):na,  
     array.size(mergeLow)>0?array.last(mergeLow):na,
     array.size(mergeLow)>0?array.last(mergeLow):na,
     color = color.rgb(255, 255, 255, 100),  
     wickcolor = color.black)
if(isCyc)
    //table.cell(suggestInfo,0,3,"wx:fanjianqiang2007",text_size = size.large)
    //å¤„ç†ç¬”çš„ä¸šåŠ¡é€»è¾‘
    penHandler(isTopOrBottom,topOrBottomTime,topOrBottomPrice)
    if(array.size(pens) > 0 )
        _realLastPen := array.last(pens)
    //æå‰ç»˜åˆ¶ä¸­æ¢
    if(p_isBeforeDrawPivot)
        beforeDrawPivot(1)
    if(p_isBeforeDrawCurrentPivot)
        beforeDrawPivot(2)
    //ç»˜åˆ¶é«˜çº§åˆ«çº¿æ®µåŠæœ¬çº§åˆ«ä¸­æ¢
    // if(array.size(segments)>0 and isTopOrBottom!=0)
    //     createSegment(2)
    //å¤„ç†é¡¶åº•äº‹ä»¶(æ­¤å¤„æœ‰é—®é¢˜ï¼Œå½“å‘ä¸Šç¬”æœ€åä¸€ä¸ªå‡ºç°åº•åˆ†å‹ä¹Ÿæ‰§è¡Œä¸€æ¬¡ï¼Œæå‰æ˜¾ç¤ºäº†ä¹°å–ç‚¹)
    if(array.size(peekEvents)>0 and not na(_realLastPen) )
        //ç»˜åˆ¶é¡¶åº•åˆ†å‹
        if(_realLastPen.direction ==-1)
            setTopBottomLabel(_realLastPen,_realLastPen.endTime,_realLastPen.low,-1)
        else
            setTopBottomLabel(_realLastPen,_realLastPen.endTime,_realLastPen.high,1)
        //æ˜¾ç¤ºå¼ºåŠ¿åˆ†å‹
        if(isPowerfulPeek)
            drawPowerfulPeek(_realLastPen,array.last(peekEvents))
        //æç¤ºä¹°å–ç‚¹
        if(_realLastPen.direction == (array.last(peekEvents)).isTopOrBottom )
            penOperateHandler(1)
            penOperateHandler(2)
    if(array.size(trendEvents) > 0)
        createSegment(2)
        array.clear(trendEvents)
    //ç‰¹å¾åºåˆ—
    //if(isTopOrBottom != 0)
    drawFeature(1)
    //åç»­æ¸…ç†å·¥ä½œ
    //æ¸…ç†äº‹ä»¶: äº‹ä»¶åœ¨ä¸Šé¢å·²ç»ä½¿ç”¨ï¼Œç›´æ¥æ¸…ç†
    array.clear(peekEvents)

//#region å‡çº¿ç³»ç»Ÿ
ma1 = ma(ma1_source, ma1_length, ma1_type)
plot(show_ma1 ? ma1 : na, color = ma1_color, title="MA1",linewidth = ma1__width)
ma2 = ma(ma2_source, ma2_length, ma2_type)
plot(show_ma2 ? ma2 : na, color = ma2_color, title="MA2",linewidth = ma2__width)
ma3 = ma(ma3_source, ma3_length, ma3_type)
plot(show_ma3 ? ma3 : na, color = ma3_color, title="MA3",linewidth = ma3__width)
ma4 = ma(ma4_source, ma4_length, ma4_type)
plot(show_ma4 ? ma4 : na, color = ma4_color, title="MA4",linewidth = ma4__width)
ma5 = ma(ma5_source, ma5_length, ma5_type)
plot(show_ma5 ? ma5 : na, color = ma5_color, title="MA5",linewidth = ma5__width)
ma6 = ma(ma6_source, ma6_length, ma6_type)
plot(show_ma6 ? ma6 : na, color = ma6_color, title="MA6",linewidth = ma6__width)
ma7 = ma(ma7_source, ma7_length, ma7_type)
plot(show_ma7 ? ma7 : na, color = ma7_color, title="ma7",linewidth = ma7__width)
ma8 = ma(ma8_source, ma8_length, ma8_type)
plot(show_ma8 ? ma8 : na, color = ma8_color, title="ma8",linewidth = ma8__width)  

